/******************************************************************************
* @license
* Copyright (C) 2008-2014, Roman Lygin. All rights reserved.
* Copyright (C) 2014-2023, CADEX. All rights reserved.
*
* This file is part of the CAD Exchanger software.
*
* This file may be used under the terms and conditions of the License
* Agreement supplied with the software.
*
* This file is provided "AS IS" WITH NO WARRANTY OF ANY KIND, EITHER EXPRESSED
* OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE WARRANTY OF DESIGN,
* MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
*
*****************************************************************************/


// https://github.com/Microsoft/TypeScript/issues/27024#issuecomment-421529650
type IfEquals<X, Y, A, B> =
    (<T>() => T extends X ? 1 : 2) extends
    (<T>() => T extends Y ? 1 : 2) ? A : B;

type FieldKeys<T> = ({
    [P in keyof T]: T[P] extends Function ? never : P
})[keyof T];

type WritableFieldKeys<T> = ({
    [P in keyof T]: T[P] extends Function
        ? never
        : IfEquals<{ [Q in P]: T[P] }, { -readonly [Q in P]: T[P] }, P & string, never>
})[keyof T];

type ModelPrs_FieldChangedEventMap<T extends ModelPrs_EventDispatcher> = {
  [p in `${WritableFieldKeys<T>}Changed`]: ModelPrs_Event<p, T>;
};

/**
 * Predefined list of angle units.
 */
export enum Base_AngleUnit {
    Base_AU_Radians = 0,
    Base_AU_Degrees = 1,
}


export class Base_Helper {
    static angleUnitCoef(theUnit: Base_AngleUnit): number;
    static angleUnitSymbol(theUnit: Base_AngleUnit): string;
    /**
     * Returns coefficient for conversion from millimeters to target unit.
     */
    static lengthUnitCoef(theUnit: Base_LengthUnit): number;
    static lengthUnitSymbol(theUnit: Base_LengthUnit): string;
}

/**
 * Predefined list of length units.
 */
export enum Base_LengthUnit {
    Base_LU_Millimeters = 0,
    Base_LU_Centimeters = 1,
    Base_LU_Meters = 2,
    Base_LU_Inches = 3,
    Base_LU_Feets = 4,
    Base_LU_Yards = 5,
    Base_LU_Micrometers = 6,
    Base_LU_Decimeters = 7,
    Base_LU_Kilometers = 8,
    Base_LU_Mils = 9,
    Base_LU_Miles = 10,
}

/**
 * Represents a node in a hierarchy of progress scopes.
 * 
 * Scopes can be used to recursively split the range of {@link Base_ProgressStatus} object.
 * {@link Base_ProgressStatus} internally maintains a stack of created scopes.
 * Whenever a scope is closed it notifies its parent by incrementing its value,
 * the parent notifies its own parent and so on up to the {@link Base_ProgressStatus} object itself.
 * 
 * Each scope has a range which is by default [0, 100]. A child scope is created
 * as a portion of the parent scope (specified in the constructor).
 * This weight information is used to compute increment in the parent range
 * when the child scope's value changes.
 */
export class Base_ProgressScope {
    /**
     * Creates a scope as a portion of the explicitly specified parent scope.
     * 
     * `theScaleInParentRange` specifies a portion of the parent scope's remaining range,
     * which this scope corresponds to. `theScaleInParentRange` is specified in parent's range units.
     * If it is negative then the entire parent's range will be used by this child scope.
     * 
     * Before creating a child scope a parent scope must already be set up with {@link Base_ProgressScope#setRange setRange}.
     */
    constructor(theParentScope: Base_ProgressScope, theScaleInParentRange?: number);
    /**
     * Indicates close the scope when the `value` reaches the `maxValue` or not.
     * Default is `true`.
     */
    get autoClose(): boolean;
    set autoClose(theAutoClose: boolean);
    /**
     * Max value set with `setRange` or 100 by default.
     */
    get maxValue(): number;
    /**
     * Min value set with `setRange` or 0 by default.
     */
    get minValue(): number;
    /**
     * The progress status which the progress scope created for.
     */
    get owner(): Base_ProgressStatus;
    /**
     * The value is in the range.
     */
    get value(): number;
    /**
     * Closes current scope. Changes after closing is not applied to the parent scope.
     */
    close(): void;
    /**
     * Increments the value by specific value.
     */
    increment(theStep?: number): void;
    /**
     * The range must be set before creating child scopes.
     * Default range is [0, 100].
     */
    setRange(theMin: number, theMax: number): void;
}

/**
 * Defines function which returns a boolean value whether the operation has been canceled.
 * Once the checker has returned `true`, the value is stored and no further calls are made.
 * 
 * The function must be fast enough as it can be called very frequently.
 * 
 * > __Note__: this property performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_base___progress_status_1_1_cancellation_checker.html CancellationChecker} class.
 */
 export type Base_ProgressStatusCancellationChecker = () => boolean;

/**
 * Provides progress status and notification mechanism.
 * 
 * Base_ProgressStatus has a current `value` which belongs to the range [0, 100]. The
 * algorithms that support progress status update increment this value during their execution.
 * 
 * Upon value change the status object notifies its observers (subclasses of the
 * {@link Base_ProgressStatusObserver} class) registered with the `register` method.
 * Thus, it implements the observer design pattern.
 * 
 * In the case there are no observers, the progress status incurs minimum overhead to the algorithm.
 * 
 * Base_ProgressScope objects can be used to split progress status range into smaller scopes.
 * The scopes can be nested.
 */
export class Base_ProgressStatus {
    /**
     * Creates an instance of Base_ProgressStatus.
     */
    constructor();
    /**
     * Maximum value of the progress status. By convention it's 100.
     */
    static readonly maxValue: number;
    /**
     * Minimum value of the progress status. By convention it's 0.
     */
    static readonly minValue: number;
    /**
     * Cancellation checker.
     */
    cancellationChecker: Base_ProgressStatusCancellationChecker | null;
    /**
     * Root progress scope.
     */
    get rootScope(): Base_ProgressScope;
    /**
     * Current value. The value is in the range [0, 100].
     */
    get value(): number;
    /**
     * Sets the flag that the operation has been canceled.
     */
    cancel(): void;
    /**
     * Adds an observer that will be notified when the progress status has changed.
     * 
     * Registered observers will receive notification of a new value of this status object
     * if the both following conditions are true:
     * * the difference between a value used in previous notification is equal to or greater than `theValueThreshold` and
     * * the time passed since previous notification is equal to or greater `theTimeThreshold` (specified in milliseconds).
     * 
     * Changing these thresholds you can manipulate frequency of the notifications for each observer.
     */
    register(theObserver: Base_ProgressStatusObserver, theValueThreshold?: number, theTimeThreshold?: number): void;
    unregister(theObserver: Base_ProgressStatusObserver): void;
    /**
     * Returns `true` if the operation has been canceled.
     */
    wasCanceled(): boolean;
}


export abstract class Base_ProgressStatusObserver {
    canceled(theStatus: Base_ProgressStatus): void;
    abstract changedValue(theStatus: Base_ProgressStatus): void;
    abstract completed(theStatus: Base_ProgressStatus): void;
}

/**
 * Defines a Universally Unique IDentifier (UUID), also known as GUIDs (Globally Unique IDentifier).
 */
export class Base_Uuid {
    /**
     * Creates an instance of Base_Uuid.
     */
    constructor(theData?: Array<number> | string | null);
    /**
     * Creates copy of the current object.
     */
    clone(): Base_Uuid;
    /**
     * Copies uuid data from another one.
     */
    copy(theUuid: Base_Uuid): this;
    /**
     * Returns `true` if this is the null UUID {00000000-0000-0000-0000-000000000000}, otherwise returns `false`.
     */
    isNull(): boolean;
    /**
     * Returns JSON representation of the uuid.
     */
    toJSON(): string;
    /**
     * Returns string representation of the uuid.
     */
    toString(): string;
}

/**
 * Computes bounding box of the objects.
 */
export class ModelAlgo_BoundingBox {
    /**
     * Computes a bounding box of a body.
     */
    static computeBodyBoundingBox(theBody: ModelData_Body, theTransformation?: ModelData_Transformation | null, theTarget?: ModelData_Box | null): ModelData_Box;
    /**
     * Computes a bounding box of a polygonal shape.
     */
    static computePolyShapeBoundingBox(thePolyShape: ModelData_PolyShape, theTransformation?: ModelData_Transformation | null, theTarget?: ModelData_Box | null): ModelData_Box;
    /**
     * Computes a bounding box of a representation.
     */
    static computeRepresentationBoundingBox(theRep: ModelData_Representation, theTransformation?: ModelData_Transformation | null, theTarget?: ModelData_Box | null): Promise<ModelData_Box>;
}

/**
 * Computes validation properties of the objects.
 */
export class ModelAlgo_ValidationProperty {
    /**
     * Calculates surface area of the body.
     */
    static computeBodySurfaceArea(theBody: ModelData_Body): number;
    /**
     * Calculates surface area of the indexed triangle set.
     */
    static computeITSSurfaceArea(theITS: ModelData_IndexedTriangleSet): number;
    /**
     * Method for calculating surface area of list of visual objects.
     */
    static computeRepresentationSurfaceArea(theRep: ModelData_Representation): Promise<number>;
}

/**
 * Provides an interface to appearance which is a collection of visual styles.
 */
export class ModelData_Appearance extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_Appearance.
     */
    constructor(theObject?: ModelData_ColorObject | ModelData_MaterialObject);
    /**
     * Generic color assigned to appearance.
     */
    get genericColor(): ModelData_ColorObject | null;
    set genericColor(theGenericColor: ModelData_ColorObject | null);
    /**
     * The line properties of appearance.
     */
    get lineProperties(): ModelData_LineProperties | null;
    set lineProperties(theLineProperties: ModelData_LineProperties | null);
    /**
     * Material object assigned to appearance.
     */
    get material(): ModelData_MaterialObject | null;
    set material(theMaterial: ModelData_MaterialObject | null);
    /**
     * Texture set assigned to appearance
     */
    get textureSet(): ModelData_TextureSet | null;
    set textureSet(theTextureSet: ModelData_TextureSet | null);
    /**
     * Adds texture to the appearance.
     */
    add(theTexture: ModelData_Texture): void;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Appearance;
    /**
     * Combines appearance with current.
     */
    combineWith(theAppearance: ModelData_Appearance): this;
    /**
     * Copies appearance params from another appearance.
     */
    copy(theAppearance: ModelData_Appearance): this;
    /**
     * Copies internal contents and combines with set attributes from another appearance.
     */
    copyAndCombineWith(theAppearance: ModelData_Appearance): ModelData_Appearance;
    /**
     * Equality operator.
     * Returns `true` if both appearances have equal colors, materials and textures.
     */
    isEqual(theAppearance: ModelData_Appearance | null | undefined): boolean;
    /**
     * Updates appearance.
     */
    set(theObject?: ModelData_ColorObject | ModelData_MaterialObject | null): void;
    /**
     * Returns `true` if there is any style item which allows to retrieve a color.
     * 
     * If there is a {@link ModelData_Appearance#genericColor genericColor} then theColor will be assigned its value.
     * Otherwise, if there is a {@link ModelData_Appearance#material material} then theColor will be assigned its diffuse color value.
     * 
     * Otherwise returns `false`.
     */
    toColor(theColor: ModelData_ColorObject): boolean;
    /**
     * Returns `true` if there is any style item which allows to convert this appearance to a material.
     * 
     * If there is a {@link ModelData_Appearance#material material} then theMaterial will be assigned its value.
     * If there is a {@link ModelData_Appearance#genericColor genericColor} then theMaterial will have diffuse color of that value and other default colors will have default values.
     * 
     * Otherwise returns `false`.
     */
    toMaterial(theMaterial: ModelData_MaterialObject): boolean;
}

/**
 * Defines a group of scene graph element.
 */
export class ModelData_Assembly extends ModelData_SceneGraphElement {
    /**
     * Creates an instance of ModelData_Assembly.
     */
    constructor();
    /**
     * Number of instances in this assembly.
     */
    get numberOfInstances(): number;
    /**
     * Adds a new child element into the assembly.
     * Assemblies may only have instances as direct children. If theElement is not an instance (i.e. is a part
     * or an assembly) then an interim instance is created which will refer to theElement.
     */
    addInstance(theElement: ModelData_Instance | ModelData_Part | ModelData_Assembly, theTransformation?: ModelData_Transformation, theName?: string): ModelData_Instance | null;
    /**
     * Returns iterable to added instances.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const instance of assembly.instances()) {
     *   // Access to the instance
     * }
     * ```
     */
    instances(): Iterable<ModelData_Instance>;
}

/**
 * Defines an axis placement as a combination of point and direction.
 */
export class ModelData_Axis1Placement {
    /**
     * Creates an axis from origin point and direction.
     */
    constructor(theLocation?: ModelData_Point, theDirection?: ModelData_Direction);
    /**
     * Direction of the axis placement.
     */
    get direction(): ModelData_Direction;
    /**
     * Location point of the axis placement.
     */
    get location(): ModelData_Point;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Axis1Placement;
    /**
     * Copies axis params from another axis.
     */
    copy(theAxis: ModelData_Axis1Placement): this;
}

/**
 * Defines a right-hand axis placement in 3D.
 * 
 * An axis placement is defined by a location point, a Z-direction and a reference direction (XRef).
 * 
 * The Z-direction defines a plane perpendicular to Z. Other directions are defined as follows:
 * * the Y-direction is defined as a cross-product of the Z-direction and the reference direction;
 * * the X-direction is defined as a cross-product of the Y-direction and the Z-direction.
 * 
 * X,Y,Z axes always define a right-hand axis placement.
 */
export class ModelData_Axis2Placement {
    /**
     * Creates an axis from origin point, direction and a referenced direction.
     */
    constructor(theLocation: ModelData_Point, theDirection: ModelData_Direction, theRefDirection: ModelData_Direction);
    /**
     * Z-direction of the axis placement.
     */
    get axis(): ModelData_Direction;
    /**
     * Location point of the axis placement.
     */
    get location(): ModelData_Point;
    /**
     * X-direction of the axis placement.
     */
    get xDirection(): ModelData_Direction;
    /**
     * Y-direction of the axis placement.
     */
    get yDirection(): ModelData_Direction;
}

/**
 * Defines a right-handed or left-handed axis placement in 3D.
 * 
 * An axis placement is defined similar to ModelData_Axis2Placement, however its directions
 * can be reversed independently.
 */
export class ModelData_Axis3Placement {
    /**
     * Creates an axis from origin point, direction and a referenced direction.
     */
    constructor(theLocation?: ModelData_Point, theDirection?: ModelData_Direction, theRefDirection?: ModelData_Direction);
    /**
     * Z-direction of the axis placement.
     */
    get axis(): ModelData_Direction;
    /**
     * Location point of the axis placement.
     */
    get location(): ModelData_Point;
    /**
     * X-direction of the axis placement.
     */
    get xDirection(): ModelData_Direction;
    /**
     * Y-direction of the axis placement.
     */
    get yDirection(): ModelData_Direction;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Axis3Placement;
    /**
     * Copies axis params from another axis.
     */
    copy(theAx3: ModelData_Axis3Placement): this;
}

/**
 * Base class for all Objects.
 */
export class ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_BaseObject.
     */
    constructor(theName?: string | null, theUuid?: Base_Uuid | null);
    /**
     * Object name. `null` if the object has no name (by default).
     */
    name: string | null;
    /**
     * Object uuid. `null` if the object has no uuid (by default).
     */
    uuid: Base_Uuid | null;
}

/**
 * Defines a root topological shape that can be owned by {@link ModelData_BRepRepresentation B-Rep representation}.
 * 
 * Depending on its type, a body can hold either:
 * * acorn body - {@link ModelData_Vertex}
 * * solid body - {@link ModelData_Solid} (which can be a solid with voids),
 * * wireframe body - {@link ModelData_Edge}, {@link ModelData_Wire} or a group thereof,
 * * sheet body - {@link ModelData_Face}, {@link ModelData_Shell} or a group thereof
 */
export class ModelData_Body extends ModelData_Shape {
    /**
     * Body type.
     */
    get bodyType(): ModelData_BodyType;
    /**
     * Body poly presentation.
     */
    get prs(): ModelData_BodyPrs | null;
    /**
     * Creates a body from an arbitrary shape.
     * If `theShape` is already a body then just returns it.
     * If `theShape` is a body list then returns its first body or empty, if the list is empty.
     * Otherwise creates a body wrapping `theShape`.
     */
    static create(theShape: ModelData_Shape): ModelData_Body | null;
    /**
     * Adds a shape to the body.
     * Returns `true` if the shape has been successfully added and `false` otherwise.
     * Result depends upon the existing body contents and the shape being added. The check are applied in the following order:
     * * if the body is either solid or acorn then returns `false`;
     * * if `theShape` is simple (i.e. from vertex to solid) and the body is either wireframe or sheet
     *      then either appends the shape and returns `true` (if the types of the shape and body are compatible)
     *      or returns `false` (if the types are incompatible).
     * * if `theShape` is a body of the same type as this body, then adds its components and returns `true`.
     *      Returns `false` if the types are incompatible.
     * * if `theShape` is a body list then tries to add its bodies using the above approach.
     *      Returns `true` if at least one body succeeded.
     */
    append(theShape: ModelData_Shape): boolean;
}

/**
 * Defines a list of bodies.
 * Body list is used by {@link ModelData_BRepRepresentation} to hold root bodies.
 */
export class ModelData_BodyList extends ModelData_Shape {
    [Symbol.iterator](): Iterator<ModelData_Body>;
    /**
     * Adds body to the body list.
     */
    append(theBody: ModelData_Body): void;
    /**
     * Retrieve body by index.
     */
    element(theIndex: number): ModelData_Body | undefined;
    /**
     * Returns the number of added bodies.
     */
    size(): number;
}

/**
 * Defines poly presentation of body.
 * Contains multiple {@link ModelData_PolyVertexSet PolyVertexSets} for different sub-shape types.
 */
export class ModelData_BodyPrs {
    edges: ModelData_PolyLineSet | undefined;
    faces: ModelData_IndexedTriangleSet | undefined;
    vertexes: ModelData_PolyPointSet | undefined;
}

/**
 * Defines a body type.
 */
export enum ModelData_BodyType {
    /**
     * Unknown body type
     */
    Undefined = 0,
    /**
     * Acorn body type
     */
    Acorn = 1,
    /**
     * Wireframe body type
     */
    Wireframe = 2,
    /**
     * Sheet body type
     */
    Sheet = 3,
    /**
     * Solid body type
     */
    Solid = 4,
}

/**
 * Defines a 3D axis-aligned bounding box.
 * 
 * The box is defined via two corners - {@link ModelData_Box#minCorner} and {@link ModelData_Box#maxCorner}
 * - containing minimum and maximum coordinates respectively.
 */
export class ModelData_Box {
    /**
     * Creates a box with specified minimum and maximum corners.
     */
    constructor(theMinCorner?: ModelData_XYZ, theMaxCorner?: ModelData_XYZ);
    /**
     * Maximum corner of the bounding box.
     */
    maxCorner: ModelData_Point;
    /**
     * Minimum corner of the bounding box.
     */
    minCorner: ModelData_Point;
    /**
     * Accumulates another bounding box or point.
     */
    add(theObject: ModelData_Point | ModelData_Box | Object): this;
    /**
     * Resets the bounding box.
     */
    clear(): this;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Box;
    /**
     * Copies values from another box.
     */
    copy(theBox: ModelData_Box | Object): this;
    /**
     * Returns a middle of the diagonal between `minCorner` and `maxCorner`.
     */
    getCenter(theTarget?: ModelData_Point): ModelData_Point;
    /**
     * Returns `true` if the box includes zero points within its bounds.
     * > __Note__: a box with equal min and max corners still includes one point, the one both corners share.
     */
    isEmpty(): boolean;
    /**
     * Compares two boxes with specified tolerance.
     */
    isEqual(theOther: ModelData_Box, theTolerance?: number): boolean;
    /**
     * Returns `true` if at least one coordinate is infinite.
     */
    isInfinite(): boolean;
    /**
     * Returns JSON representation of the box.
     */
    toJSON(): Object;
    /**
     * Returns string representation of the box.
     */
    toString(): string;
    /**
     * Returns the length of range along X axis.
     */
    xRange(): number;
    /**
     * Returns the length of range along Y axis.
     */
    yRange(): number;
    /**
     * Returns the length of range along Z axis.
     */
    zRange(): number;
}

/**
 * Defines a 2D bounding box.
 * 
 * The box is defined via two corners - {@link ModelData_Box2d#minCorner} and {@link ModelData_Box2d#maxCorner}
 * - containing minimum and maximum coordinates respectively.
 */
export class ModelData_Box2d {
    /**
     * Creates a box with specified minimum and maximum corners.
     */
    constructor(theMinCorner?: ModelData_XY, theMaxCorner?: ModelData_XY);
    /**
     * Maximum corner of the bounding box.
     */
    maxCorner: ModelData_Point2d;
    /**
     * Minimum corner of the bounding box.
     */
    minCorner: ModelData_Point2d;
    /**
     * Accumulates another bounding box or point.
     */
    add(theObject: ModelData_Point2d | ModelData_Box2d | Object): this;
    /**
     * Resets the bounding box.
     */
    clear(): this;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Box2d;
    /**
     * Copies values from another box.
     */
    copy(theBox: ModelData_Box2d | Object): this;
    /**
     * Returns a middle of the diagonal between `minCorner` and `maxCorner`.
     */
    getCenter(theTarget?: ModelData_Point2d): ModelData_Point2d;
    /**
     * Returns `true` if the box includes zero points within its bounds.
     * > __Note__: a box with equal min and max corners still includes one point, the one both corners share.
     */
    isEmpty(): boolean;
    /**
     * Compares two boxes with specified tolerance.
     */
    isEqual(theOther: ModelData_Box2d, theTolerance?: number): boolean;
    /**
     * Returns `true` if at least one coordinate is infinite.
     */
    isInfinite(): boolean;
    /**
     * Returns JSON representation of the box.
     */
    toJSON(): Object;
    /**
     * Returns string representation of the box.
     */
    toString(): string;
    /**
     * Returns the length of range along X axis.
     */
    xRange(): number;
    /**
     * Returns the length of range along Y axis.
     */
    yRange(): number;
}

/**
 * Defines B-Rep representation of part.
 * A part corresponds to mechanical part or a product in the product structure hierarchy.
 * A part contains one or several representations: zero or one B-Rep representation, and/or
 * zero, one or multiple polygonal representations.
 */
export class ModelData_BRepRepresentation extends ModelData_Representation {
    /**
     * Creates an instance of ModelData_BRepRepresentation.
     */
    constructor(theBody?: ModelData_Body);
    /**
     * Number of subshapes.
     */
    get numberOfSubshapes(): number;
    /**
     * Accepts a subshape visitor.
     */
    acceptSubshapeVisitor(theVisitor: ModelData_BRepRepresentationSubshapeVisitor): void;
    /**
     * Adds a root body.
     */
    add(theBody: ModelData_Body): void;
    /**
     * Add the PMI data to the subshape.
     */
    addPMIData(theShape: ModelData_Shape, thePMIData: ModelData_PMIData): void;
    /**
     * Adds B-Rep representations provider.
     */
    addProvider(theProvider: ModelData_BRepRepresentationProvider): void;
    /**
     * Returns bodies list. This method flushes providers.
     */
    bodyList(theScope?: Base_ProgressScope): Promise<ModelData_BodyList>;
    /**
     * Returns `true` if BRep representations has subshapes.
     */
    hasSubshapes(): boolean;
    /**
     * Returns iterable to added PMI data associated with the subshapes.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const shape of bRepRep.subshapes()) {
     *   for (const pmiData of bRepRep.pmiData(shape)) {
     *      // Access to the PMI data
     *   }
     * }
     * ```
     * 
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___b_rep_representation_1_1_p_m_i_data_iterator.html ModelData_BRepRepresentation::PMIDataIterator} class.
     */
    pmiData(theShape: ModelData_Shape): Iterable<ModelData_PMIData>;
    /**
     * Returns a B-Rep shape by its id.
     * If `theId` is negative or there is no corresponding shape in this representation, then returns null.
     */
    shape(theId: number): ModelData_Shape | null;
    /**
     * Returns an id of B-Rep shape.
     * If the shape does not belong to B-Rep, then returns -1.
     */
    shapeId(theShape: ModelData_Shape): number;
    /**
     * Returns iterable to subshapes.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const shape of bRepRep.subshapes()) {
     *   // Access to the subshape
     * }
     * ```
     * 
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___b_rep_representation_1_1_subshape_iterator.html ModelData_BRepRepresentation::SubshapeIterator} class.
     */
    subshapes(): Iterable<ModelData_Shape>;
}

/**
 * Provides {@link ModelData_BRepRepresentation B-Rep representation}.
 * 
 * Used to defer construction of the B-Rep representation and thereby to reduce peak memory footprint.
 */
export abstract class ModelData_BRepRepresentationProvider {
    /**
     * Feeds the representation.
     * This method can depend of the network request which makes asynchronously, so it should return Promise.
     * Subclasses must redefine this method to call {@link ModelData_BRepRepresentation#add add()}
     * of theRepresentation.
     */
    abstract feed(theRepresentation: ModelData_BRepRepresentation, theScope: Base_ProgressScope): Promise<void>;
}

/**
 * Defines a visitor of the subshapes.
 */
export abstract class ModelData_BRepRepresentationSubshapeVisitor {
    abstract visit(theShape: ModelData_Shape): void;
}

/**
 * Defines an RGBA color (with alpha channel).
 * Components must be within a [0, 1] range.
 */
export class ModelData_ColorObject extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_Color. Each value must be within [0, 1] range.
     */
    constructor(r?: number, g?: number, b?: number, a?: number);
    /**
     * Precision of color components.
     */
    static readonly precision: number;
    /**
     * Alpha component of the color. Value must be within [0, 1] range.
     */
    get a(): number;
    set a(theValue: number);
    /**
     * Blue component of the color. Value must be within [0, 1] range.
     */
    get b(): number;
    set b(theValue: number);
    /**
     * Green component of the color. Value must be within [0, 1] range.
     */
    get g(): number;
    set g(theValue: number);
    /**
     * Red component of the color. Value must be within [0, 1] range.
     */
    get r(): number;
    set r(theValue: number);
    /**
     * Creates color from integer which represents RGB.
     */
    static fromHex(theHex: number, a?: number): ModelData_ColorObject;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_ColorObject;
    /**
     * Copies values from another color to current.
     */
    copy(theColor: ModelData_ColorObject): this;
    /**
     * Equality operator.
     * Returns `true` if all color components are the same or
     * differences between the component do not exceed {@link ModelData_ColorObject.precision precision}.
     */
    isEqual(theColor: ModelData_ColorObject | null | undefined): boolean;
    /**
     * Set color components.
     */
    set(r?: number, g?: number, b?: number, a?: number): this;
    /**
     * Set color from integer which represents RGB. Alpha component will not be changed.
     */
    setHex(theHex: number): this;
    /**
     * Change component value by index.
     */
    setValue(theIndex: number, theValue: number): void;
    /**
     * Returns JSON representation of the color.
     */
    toJSON(): Object;
    /**
     * Returns string representation of the color.
     */
    toString(): string;
    /**
     * Returns component value by index.
     */
    value(theIndex: number): number;
}

/**
 * Provides combined methods VisitElementEnter() and VisitElementLeave() to visit all elements.
 * This visitor corresponds to the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___model_1_1_combined_element_visitor.html ModelData_Model::CombinedElementVisitor} class.
 */
export abstract class ModelData_CombinedSceneGraphElementVisitor extends ModelData_SceneGraphElementVisitor {
    visitAssemblyEnter(theAssembly: ModelData_Assembly): Promise<boolean> | boolean;
    visitAssemblyLeave(theAssembly: ModelData_Assembly): Promise<void> | void;
    abstract visitElementEnter(theElement: ModelData_SceneGraphElement): Promise<boolean> | boolean;
    abstract visitElementLeave(theElement: ModelData_SceneGraphElement): Promise<void> | void;
    visitInstanceEnter(theInstance: ModelData_Instance): Promise<boolean> | boolean;
    visitInstanceLeave(theInstance: ModelData_Instance): Promise<void> | void;
    visitPart(thePart: ModelData_Part): Promise<void> | void;
}

/**
 * Base class for 3D curves.
 * 
 * 3D curves are used to represent curves in 3D space. Each non-degenerated
 * {@link ModelData_Edge "edge"} must refer to a 3D curve.
 * 
 * > __Note__: This class is defined for SDK API compatibility only.
 * Unlike {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___curve.html C++ SDK Curve}
 * it contains only type of the curve.
 */
export class ModelData_Curve {
    /**
     * Curve type.
     */
    get type(): ModelData_CurveType;
}

/**
 * Defines curve type.
 */
export enum ModelData_CurveType {
    Line = 0,
    Circle = 1,
    Ellipse = 2,
    Hyperbola = 3,
    Parabola = 4,
    Bezier = 5,
    BSpline = 6,
    Offset = 7,
    Trimmed = 8,
    Undefined = 100,
    UserDefine = 101,
}

/**
 * Represents direction in 3D space.
 */
export class ModelData_Direction {
    /**
     * Creates Direction of object or three numbers.
     */
    constructor(x?: number, y?: number, z?: number);
    /**
     * A tolerance to compare coincidence of two direction.
     */
    static readonly coincidenceTolerance: number;
    /**
     * X coord.
     */
    get x(): number;
    set x(x: number);
    /**
     * Y coord.
     */
    get y(): number;
    set y(y: number);
    /**
     * Z coord.
     */
    get z(): number;
    set z(z: number);
    /**
     * Creates direction from object implementing {@link ModelData_XYZ} interface.
     */
    static fromXYZ(theXYZ: ModelData_XYZ): ModelData_Direction;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Direction;
    /**
     * Copies values from another direction.
     */
    copy(theDirection: ModelData_Direction): this;
    /**
     * Makes cross product with another direction.
     */
    cross(theDirection: ModelData_XYZ): this;
    /**
     * Makes cross product from current direction and with another one.
     */
    crossed(theDirection: ModelData_XYZ): ModelData_Direction;
    /**
     * Returns a dot-product.
     */
    dot(theDirection: ModelData_XYZ): number;
    /**
     * Compares if two direction are equal within a distance tolerance.
     */
    isEqual(theXYZ: ModelData_XYZ, theTolerance?: number): boolean;
    /**
     * Compares if two direction are parallel within a distance tolerance.
     */
    isParallel(theOther: ModelData_Direction, theTolerance: number): boolean;
    /**
     * Reverses the direction.
     */
    reverse(): this;
    /**
     * Returns a direction which is a reversed direction of this.
     */
    reversed(): ModelData_Direction;
    /**
     * Sets coordinates.
     */
    setCoord(x: number, y: number, z: number): this;
    /**
     * Returns JSON representation of the direction.
     */
    toJSON(): ModelData_XYZ;
    /**
     * Returns string representation of the direction.
     */
    toString(): string;
    /**
     * Transforms the point with a transformation matrix.
     */
    transform(theTransformation: ModelData_Transformation): this;
    /**
     * Returns a new point which is transformed with a transformation matrix.
     */
    transformed(theTransformation: ModelData_Transformation): ModelData_Direction;
}

/**
 * Represents direction in 2D space.
 */
export class ModelData_Direction2d {
    /**
     * Creates instance of the ModelData_Direction2d.
     */
    constructor(x?: number, y?: number);
    /**
     * A tolerance to compare coincidence of two direction.
     */
    static readonly coincidenceTolerance: number;
    /**
     * X coord.
     */
    get x(): number;
    set x(x: number);
    /**
     * Y coord.
     */
    get y(): number;
    set y(y: number);
    /**
     * Creates direction from object implementing {@link ModelData_XY} interface.
     */
    static fromXY(theXY: ModelData_XY): ModelData_Direction2d;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Direction2d;
    /**
     * Copies values from another direction.
     */
    copy(theDirection: ModelData_Direction2d): this;
    /**
     * Makes cross product with another direction.
     */
    cross(theDirection: ModelData_Direction2d): number;
    /**
     * Returns a dot-product.
     */
    dot(theDirection: ModelData_Direction2d): number;
    /**
     * Compares if two direction are equal within a distance tolerance.
     */
    isEqual(theXY: ModelData_XY, theTolerance?: number): boolean;
    /**
     * Compares if two direction are parallel within a distance tolerance.
     */
    isParallel(theOther: ModelData_Direction2d, theTolerance: number): boolean;
    /**
     * Reverses the direction.
     */
    reverse(): this;
    /**
     * Returns a direction which is a reversed direction of this.
     */
    reversed(): ModelData_Direction2d;
    /**
     * Sets coordinates.
     */
    setCoord(x: number, y: number): this;
    /**
     * Returns JSON representation of the direction.
     */
    toJSON(): ModelData_XY;
    /**
     * Returns string representation of the direction.
     */
    toString(): string;
}

/**
 * Defines an edge.
 */
export class ModelData_Edge extends ModelData_Shape {
    /**
     * Edge 3D curve.
     */
    get curve(): ModelData_Curve | null;
    /**
     * End vertex.
     */
    get endVertex(): ModelData_Vertex | null;
    /**
     * Start vertex.
     */
    get startVertex(): ModelData_Vertex;
    /**
     * Creates an instance of ModelData_Edge from the curve and vertexes.
     */
    static create(theCurve: ModelData_Curve, theStartVertex: ModelData_Vertex, theEndVertex: ModelData_Vertex): ModelData_Edge;
}

/**
 * Base class for elementary surfaces.
 * 
 * Elementary surface has an axis placement returned by Position().
 */
export class ModelData_ElementarySurface {
    constructor(thePlacement: ModelData_Axis3Placement);
    /**
     * Z-direction of the axis placement.
     */
    get direction(): ModelData_Direction;
    /**
     * Origin point.
     */
    get location(): ModelData_Point;
    /**
     * Surface axis.
     */
    get position(): ModelData_Axis3Placement;
}

/**
 * Defines a topological face.
 * 
 * Face resides on a geometrical surface and is bounded by one or several wires.
 */
export class ModelData_Face extends ModelData_Shape {
    /**
     * Underlying surface.
     */
    get surface(): ModelData_Surface | null;
    /**
     * Creates an instance of ModelData_Face from the surface and wires.
     */
    static create(theSurface: ModelData_Surface, theWire?: ModelData_Wire): ModelData_Face;
    [Symbol.iterator](): Iterator<ModelData_Wire>;
    /**
     * Adds a wire to the face.
     */
    append(theWire: ModelData_Wire): boolean;
}

/**
 * Provides a texture defined by file url.
 */
export class ModelData_FileTexture extends ModelData_Texture {
    /**
     * Creates an instance of ModelData_FileTexture.
     */
    constructor(theFilePath: string | null, theTextureType?: ModelData_TextureType, theTextureParameters?: ModelData_TextureParameters | null);
    /**
     * A file path to the file.
     */
    get filePath(): string | null;
    /**
     * Texture data provider.
     */
    get provider(): ModelData_FileTextureProvider | undefined;
    set provider(theProvider: ModelData_FileTextureProvider | undefined);
    /**
     * Returns image. This method flushes provider.
     * 
     * > __Note__: the file path should be relative of the model scenegraph location.
     */
    image(theScope?: Base_ProgressScope): Promise<(HTMLImageElement|HTMLCanvasElement|ImageBitmap|null)>;
}

/**
 * Used to defer loading of image of the file texture.
 */
export abstract class ModelData_FileTextureProvider {
    /**
     * Feeds the file texture.
     */
    abstract feed(theFileTexture: ModelData_FileTexture, theScope: Base_ProgressScope): Promise<void>;
}

/**
 * Defines a polygonal shape consisting of indexed poly lines.
 */
export class ModelData_IndexedPolyLineSet extends ModelData_PolyVertexSet {
    /**
     * Creates an instance of ModelData_IndexedPolyLineSet.
     */
    constructor();
    /**
     * Indexes array.
     */
    indexes: Uint32Array | Uint16Array | null;
}

/**
 * Defines a polygonal shape consisting of triangles.
 * 
 * Triangles are defined via array of unique vertex coordinates and triplets of indices in this array.
 * This is to describe connectivity and to reduce data required to describe a triangle set.
 * 
 * The triangle set can optionally contain normals which are defined per each vertex.
 */
export class ModelData_IndexedTriangleSet extends ModelData_PolyVertexSet {
    /**
     * Creates an instance of ModelData_IndexedTriangleSet.
     */
    constructor();
    /**
     * Indexes array.
     */
    indexes: Uint32Array | Uint16Array | null;
    /**
     * Array of vertex normals in {x,y,z} format [x,y,z,x,y,z,...].
     */
    normals: Float32Array | null;
    /**
     * Number of faces (triangles).
     */
    get numberOfFaces(): number;
    /**
     * Number of normals.
     */
    get numberOfNormals(): number;
    /**
     * Number of UV coordinates.
     */
    get numberOfUVCoordinates(): number;
    /**
     * Array of vertex UV coordinates in {u,v} format [u,v,u,v,...].
     */
    uvCoordinates: Float32Array | null;
    /**
     * Returns a coordinate index for a vertex in a face.
     */
    coordinateIndex(theFace: number, theVertexSlot: number): number;
    /**
     * Returns `true` if object has normal per vertex
     */
    hasNormals(): boolean;
    /**
     * Returns `true` if object has UV coordinates associated with vertices
     */
    hasUVCoordinates(): boolean;
    /**
     * Returns a normal per its index.
     * 
     * > __Note__: changing returned object does not change original normal.
     */
    normal(theIndex: number, theTarget: ModelData_Direction): ModelData_Direction | undefined;
    /**
     * Returns a normal index for a vertex in a face.
     */
    normalIndex(theFace: number, theVertexSlot: number): number;
    /**
     * Returns a UV coordinate associated with a vertex.
     * This method may only be used if `HasUVCoordinates()` returns `true`,
     * otherwise behavior is undefined.
     * 
     * > __Note__: changing returned object does not change original UV point.
     */
    uvCoordinate(theIndex: number, theTarget?: ModelData_Point2d): ModelData_Point2d | undefined;
    /**
     * Returns a UV coordinate index for a vertex in a face.
     * This method may only be used if `HasUVCoordinates()` returns `true`,
     * otherwise behavior is undefined.
     */
    uvCoordinateIndex(theFace: number, theVertexSlot: number): number;
}

/**
 * Defines an occurrence of assembly or part in a scene graph.
 */
export class ModelData_Instance extends ModelData_SceneGraphElement {
    /**
     * Creates an instance of ModelData_Instance.
     */
    constructor(theElement?: ModelData_Part | ModelData_Assembly, theTrsf?: ModelData_Transformation, theName?: string);
    /**
     * Referenced object.
     * Warning: there must be no cyclic references between theElement and this instance as otherwise there will
     * be memory leaks and infinite loop when visiting the scene graph.
     */
    get reference(): ModelData_SceneGraphElement | null;
    set reference(theRef: ModelData_SceneGraphElement | null);
    /**
     * The transformation of the reference. If the matrix has not been explicitly assigned with setter
     * then creates and explicitly assigns an identity matrix.
     */
    get transformation(): ModelData_Transformation;
    /**
     * > __Note__: Setter makes deep copy of the transformation.
     */
    set transformation(theTrsf: ModelData_Transformation);
    /**
     * Returns `true` if the instance has an explicitly attached transformation matrix.
     */
    hasTransformation(): boolean;
}


export class ModelData_LineProperties {
    constructor(theType?: ModelData_LineType, theWidthScaleFactor?: number);
    /**
     * Line pattern.
     */
    type: ModelData_LineType;
    /**
     * A multiplicative value that scales nominal line width.
     * A value less than or equal to zero refers to the minimum available line width.
     */
    widthScaleFactor: number;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_LineProperties;
    /**
     * Copies parameters from another object.
     */
    copy(theLineProperties: ModelData_LineProperties): this;
    /**
     * Equality operator.
     */
    isEqual(theLineProperties: ModelData_LineProperties | null | undefined): boolean;
}

/**
 * Defines the line type in accordance with International Register of Graphical Items.
 */
export enum ModelData_LineType {
    Solid = 1,
    Dashed = 2,
    Dotted = 3,
    DashedDotted = 4,
    DashDotDot = 5,
    Single = 6,
    SingleDot = 7,
    DoubleArrow = 8,
    StitchLine = 9,
    ChainLine = 10,
    CenterLine = 11,
    HiddenLine = 12,
    PhantomLine = 13,
    BreakLine1 = 14,
    BreakLine2 = 15,
    UserSpecifiedDashPattern = 16,
}

/**
 * Provides a data container for material.
 */
export class ModelData_MaterialObject extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_MaterialObject.
     */
    constructor(theAmbientColor?: ModelData_ColorObject, theDiffuseColor?: ModelData_ColorObject, theSpecularColor?: ModelData_ColorObject, theEmissionColor?: ModelData_ColorObject, theShininess?: number);
    /**
     * Ambient color.
     */
    ambientColor: ModelData_ColorObject;
    /**
     * Diffuse color.
     */
    diffuseColor: ModelData_ColorObject;
    /**
     * Emissive color.
     */
    emissiveColor: ModelData_ColorObject;
    /**
     * Shininess value. Must be within [0, 128] range.
     */
    get shininess(): number;
    set shininess(theShininess: number);
    /**
     * Specular color.
     */
    specularColor: ModelData_ColorObject;
    /**
     * Creates deep copy of the current object.
     */
    clone(): ModelData_MaterialObject;
    /**
     * Copies another material properties to current.
     */
    copy(theMaterial: ModelData_MaterialObject): this;
    /**
     * Equality operator.
     * Returns `true` if all colors of two materials are equal.
     */
    isEqual(theMaterial: ModelData_MaterialObject | null | undefined): boolean;
}

/**
 * The CDXFB data provider function type.
 */
 export type ModelData_CDXFBBufferProvider = (theFileId: string, theObjectId: string, theProgressScope: Base_ProgressScope) => Promise<ModelData_CDXFBBufferType>;

/**
 * The data type of CDXFB buffer.
 */
export type ModelData_CDXFBBufferType = ArrayBuffer;

/**
 * Result of {@link ModelData_Model#loadFile} and {@link ModelData_Model#loadSceneGraph} methods.
 */
export type ModelData_ModelLoadResult = {
    /**
     * `true` if the loaded model contains a B-Rep representation for at least one part.
     */
    hasBRepRep: boolean;
    /**
     * The maximum number of poly representations per part in the model.
     */
    polyRepCount: number;
    /**
     * List of root elements.
     */
    roots: Array<ModelData_SceneGraphElement>;
}

/**
 * Provides CAD Exchanger data model.
 * 
 * The model encapsulates a scene graph (hierarchy of assemblies and parts) and is thus an entry
 * point to entire 3D model data.
 * 
 * The model object can be and restored from a file in native CAD Exchanger format.
 * Future versions may introduce model saving to CAD Exchanger native format.
 */
export class ModelData_Model {
    /**
     * Creates an instance of ModelData_Model.
     */
    constructor(theName?: string);
    /**
     * The model name. `null` if the model has no name (by default).
     */
    name: string | null;
    /**
     * Number of root elements in the graph.
     */
    get numberOfRoots(): number;
    /**
     * Accepts an element visitor.
     */
    accept(theVisitor: ModelData_SceneGraphElementVisitor): Promise<void>;
    /**
     * Adds new root element into the scene graph.
     */
    addRoot(theRoot: ModelData_SceneGraphElement): void;
    /**
     * Loads model from model URL. All necessary data will be requested using `dataProvider`.
     */
    loadFile(theFileId: string, dataProvider: ModelData_CDXFBBufferProvider, theAppend?: boolean, theProgressScope?: Base_ProgressScope): Promise<ModelData_ModelLoadResult>;
    /**
     * Loads model from CDXFB scenegraph file. The external referenced data will be requested using `dataProvider`.
     */
    loadSceneGraph(theFileId: string, theScenegraphData: ModelData_CDXFBBufferType, dataProvider: ModelData_CDXFBBufferProvider, theAppend?: boolean): ModelData_ModelLoadResult;
    /**
     * Returns root element in the graph by index.
     */
    root(theIndex: number): ModelData_SceneGraphElement;
}

/**
 * Defines a polygonal shape consisting of indexed poly lines colored by multiple appearances.
 * 
 * Typically multi appearance indexed polyline set represents array
 * of colored indexed polyline sets merged into one big polyline set.
 * 
 * The each sub polyline set is defined as {@link ModelData_PrimitivesGroup primitivesGroup}
 * and refers to own appearance via index in {@link ModelData_MultiAppearanceIndexedPolyLineSet#appearances appearances} array.
 */
export class ModelData_MultiAppearanceIndexedPolyLineSet extends ModelData_IndexedPolyLineSet {
    /**
     * Creates an instance of ModelData_MultiAppearanceIndexedPolyLineSet.
     */
    constructor(theGroups: Array<ModelData_PrimitivesGroup>, theAppearances: Array<(ModelData_Appearance|undefined)>);
    /**
     * List of appearances references by groups.
     */
    get appearances(): ReadonlyArray<(ModelData_Appearance|undefined)>;
    /**
     * Appearance groups.
     */
    get groups(): ReadonlyArray<ModelData_PrimitivesGroup>;
}

/**
 * Defines a polygonal shape consisting of triangles colored by multiple appearances.
 * 
 * Typically multi appearance indexed triangle set represents array
 * of colored triangle sets merged into one big triangle set.
 * The each sub triangle set is defined as {@link ModelData_PrimitivesGroup primitivesGroup}
 * and refers to own appearance via index in {@link ModelData_MultiAppearanceIndexedTriangleSet#appearances appearances} array.
 */
export class ModelData_MultiAppearanceIndexedTriangleSet extends ModelData_IndexedTriangleSet {
    /**
     * Creates an instance of ModelData_MultiAppearanceIndexedTriangleSet.
     */
    constructor(theGroups: Array<ModelData_PrimitivesGroup>, theAppearances: Array<(ModelData_Appearance|undefined)>);
    /**
     * List of appearances references by groups.
     */
    get appearances(): ReadonlyArray<(ModelData_Appearance|undefined)>;
    /**
     * Appearance groups.
     */
    get groups(): ReadonlyArray<ModelData_PrimitivesGroup>;
    /**
     * Returns an appearance index for the face.
     */
    appearanceIndex(theFace: number): number;
}

/**
 * Defines a polygonal shape consisting of poly lines colored by multiple appearances.
 * 
 * Typically multi appearance polyline set represents array
 * of colored polyline sets merged into one big polyline set.
 */
export class ModelData_MultiAppearancePolyLineSet extends ModelData_PolyLineSet {
    /**
     * Creates an instance of ModelData_MultiAppearancePolyLineSet.
     */
    constructor(theGroups: Array<ModelData_PrimitivesGroup>, theAppearances: Array<(ModelData_Appearance|undefined)>);
    /**
     * List of appearances references by groups.
     */
    get appearances(): ReadonlyArray<(ModelData_Appearance|undefined)>;
    /**
     * Appearance groups.
     */
    get groups(): ReadonlyArray<ModelData_PrimitivesGroup>;
    /**
     * Returns an appearance index for the polyline.
     */
    appearanceIndex(thePolyline: number): number;
}

/**
 * Defines a polygonal shape consisting of points colored by multiple appearances.
 * 
 * Typically multi appearance point set represents array
 * of colored point sets merged into one big point set.
 * The each sub point set is defined as {@link ModelData_PrimitivesGroup primitivesGroup}
 * and refers to own appearance via index in {@link ModelData_MultiAppearancePolyPointSet#appearances appearances} array.
 */
export class ModelData_MultiAppearancePolyPointSet extends ModelData_PolyPointSet {
    /**
     * Creates an instance of ModelData_MultiAppearancePolyPointSet.
     */
    constructor(theGroups: Array<ModelData_PrimitivesGroup>, theAppearances: Array<(ModelData_Appearance|undefined)>);
    /**
     * List of appearances references by groups.
     */
    get appearances(): ReadonlyArray<(ModelData_Appearance|undefined)>;
    /**
     * Appearance groups.
     */
    get groups(): ReadonlyArray<ModelData_PrimitivesGroup>;
}

/**
 * Defines a leaf node in the scene graph hierarchy.
 * A part corresponds to mechanical part or a product in the product structure hierarchy.
 * A part contains one or several representations: zero or one B-Rep representation, and/or
 * zero, one or multiple polygonal representations.
 */
export class ModelData_Part extends ModelData_SceneGraphElement {
    /**
     * Creates an instance of ModelData_Part.
     */
    constructor(theName?: string);
    /**
     * Number of representations.
     */
    get numberOfRepresentation(): number;
    /**
     * Accepts a representation visitor.
     */
    acceptRepresentationVisitor(theVisitor: ModelData_RepresentationVisitor): Promise<void>;
    /**
     * Adds a representation.
     */
    addRepresentation(theRepresentation: ModelData_Representation): void;
    /**
     * Returns a B-Rep representation.
     * Returns undefined if there is no B-Rep representation.
     */
    brepRepresentation(): ModelData_BRepRepresentation | undefined;
    /**
     * Returns a polygonal representation that matches the specified mask.
     * Returns undefined if there is no Poly representation.
     */
    polyRepresentation(theRepresentationMask: number): ModelData_PolyRepresentation | undefined;
    /**
     * Find representation by mask or representation name. Returns undefined if there is no representation.
     */
    representation(theMaskOrName: ModelData_RepresentationMask | string): ModelData_Representation | undefined;
    /**
     * Returns iterable to added representation.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const representation of part.representations()) {
     *   // Access to the representation
     * }
     * ```
     */
    representations(): Iterable<ModelData_Representation>;
}

/**
 * Pixel format.
 */
export enum ModelData_PixelFormat {
    ModelData_PF_None = 0,
    ModelData_PF_RGB = 1,
    ModelData_PF_RGBA = 2,
    ModelData_PF_Alpha = 3,
    ModelData_PF_Luminance = 4,
    ModelData_PF_LuminanceAlpha = 5,
}

/**
 * Provides store a graphical image as a rectangular array of pixel color values.
 */
export class ModelData_PixMap {
    constructor(thePixelData: Uint8Array, theWidth: number, theHeight: number, thePixelFormat: ModelData_PixelFormat);
    /**
     * Pixmap height.
     */
    get height(): number;
    /**
     * Pixels raw data.
     */
    get pixelData(): Uint8Array;
    /**
     * Pixel format.
     */
    get pixelFormat(): ModelData_PixelFormat;
    /**
     * Pixmap width.
     */
    get width(): number;
}

/**
 * Provides a texture defined by pixel map.
 */
export class ModelData_PixMapTexture extends ModelData_Texture {
    /**
     * Creates an instance of ModelData_PixMapTexture.
     */
    constructor(thePixMap?: ModelData_PixMap | null, theTextureType?: ModelData_TextureType, theTextureParameters?: ModelData_TextureParameters | null);
    /**
     * Texture data provider.
     */
    get provider(): ModelData_PixMapTextureProvider | undefined;
    set provider(theProvider: ModelData_PixMapTextureProvider | undefined);
    /**
     * Returns pixmap. This method flushes provider.
     */
    pixmap(): Promise<(ModelData_PixMap|null)>;
}

/**
 * Used to defer loading of pixmap of the file texture.
 */
export abstract class ModelData_PixMapTextureProvider {
    /**
     * Feeds the pixmap texture.
     */
    abstract feed(thePixMapTexture: ModelData_PixMapTexture): Promise<ModelData_PixMap>;
}

/**
 * Defines a plane.
 * 
 * A plane is defined by an axis placement.
 * 
 * A plane is parameterized as follows:
 * S(u,v) = P + u * Dx + v * Dy, where
 * * P is an origin point,
 * * Dx and Dy are directions (unit vectors) of X and Y axes respectively,
 * * u, v belongs to (-infinity, +infinity).
 */
export class ModelData_Plane extends ModelData_ElementarySurface {
    /**
     * Creates a plane located in 3D space with an axis placement three axis.
     */
    constructor(thePlacement: ModelData_Axis3Placement);
    /**
     * Creates a plane from coefficients of cartesian equation:
     * `a * x + b * y + c * z + d = 0.0`
     */
    static fromEquationCoefficients(a: number, b: number, c: number, d: number): ModelData_Plane;
    /**
     * Creates a plane from origin point and the normal direction.
     */
    static fromPointAndNormal(thePoint: ModelData_Point, theNormal: ModelData_Direction): ModelData_Plane;
    /**
     * Creates a plane from tree points.
     */
    static fromThreePoints(thePoint1: ModelData_Point, thePoint2: ModelData_Point, thePoint3: ModelData_Point): ModelData_Plane;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Plane;
    /**
     * Copies plane params from another plane.
     */
    copy(thePlane: ModelData_Plane): this;
    /**
     * Calculates value at specific parameters values.
     */
    value(theParameterU: number, theParameterV: number, theTarget: ModelData_Point): void;
}

/**
 * Defines an angle unit.
 */
export class ModelData_PMIAngleUnitAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMIAngleUnitAttribute.
     */
    constructor(theUnit?: Base_AngleUnit);
    /**
     * Angle unit. Default is {@link Base_AngleUnit Base_AU_Degrees}.
     */
    unit: Base_AngleUnit;
}

/**
 * Defines a camera (point of view) in a scene.
 */
export class ModelData_PMICamera extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_PMICamera.
     */
    constructor(theLocation?: ModelData_Point, theTargetPoint?: ModelData_Point, theUpDirection?: ModelData_Direction, theName?: string);
    /**
     * Position of the camera.
     */
    location: ModelData_Point;
    /**
     * The point that the camera is looking at.
     */
    targetPoint: ModelData_Point;
    /**
     * "up" direction of the camera
     */
    upDirection: ModelData_Direction;
}

/**
 * Defines a collection of outlines.
 */
export class ModelData_PMICompositeOutline extends ModelData_PMIOutline {
    /**
     * Creates an instance of ModelData_PMICompositeOutline.
     */
    constructor();
    /**
     * Number of added outlines.
     */
    get numberOfOutlines(): number;
    /**
     * Appends an outline.
     */
    append(theOutline: ModelData_PMIOutline): void;
    /**
     * Returns `true` if no outlines have been added.
     */
    isEmpty(): boolean;
    /**
     * Returns a specified outline.
     */
    outline(theIndex: number): ModelData_PMIOutline | undefined;
    /**
     * Returns iterable to outlines.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const outline of compositeOutline.outlines()) {
     *   // Access to the outline
     * }
     * ```
     */
    outlines(): Iterable<ModelData_PMIOutline>;
}

/**
 * Defines an outline consist of 2d curves.
 */
export class ModelData_PMICurve2dOutline extends ModelData_PMIOutline {
    /**
     * Creates an instance of ModelData_PMICurve2dOutline.
     */
    constructor();
}

/**
 * Defines an outline consist of curves.
 */
export class ModelData_PMICurveOutline extends ModelData_PMIOutline {
    /**
     * Creates an instance of ModelData_PMICurveOutline.
     */
    constructor();
}

/**
 * Defines a complete PMI element. Encapsulate a PMI graphical element
 * and other PMI related information, if there is any.
 */
export class ModelData_PMIData extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_PMIData.
     */
    constructor(theType?: number, theName?: string);
    /**
     * Graphical element.
     */
    graphicalElement: ModelData_PMIGraphicalElement | null;
    /**
     * Property table.
     */
    get properties(): ModelData_PropertyTable | null;
    /**
     * Semantic element.
     */
    semanticElement: ModelData_PMISemanticElement | null;
    /**
     * PMI data type.
     */
    type: number;
    /**
     * Adds a property table to the data.
     * 
     * If this object did not have properties yet, then theProperties are just linked to this object.
     * Otherwise, the elements of theProperties are appended to existing property table (see
     * {@link ModelData_PropertyTable#add add()}).
     */
    addProperties(theProperties: ModelData_PropertyTable): void;
    /**
     * Returns `true` if no graphical element was set.
     */
    isEmpty(): boolean;
}

/**
 * Defines a component represented by a datum, datum feature symbol or datum target.
 * 
 * Datum has a label (A, B, etc.) and optionally additional attributes like index, datum target description, etc.
 */
export class ModelData_PMIDatumComponent extends ModelData_PMISemanticElementComponent {
    /**
     * Creates an instance of ModelData_PMIDatumComponent.
     */
    constructor(theLabel?: string);
    /**
     * Associated label.
     */
    label: string;
}

/**
 * Defines a datum reference.
 * Stores a label of the datum and its precedence in a compartment of a geometric tolerance.
 */
export class ModelData_PMIDatumRefAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMIDatumRefAttribute.
     */
    constructor(thePrecedence?: number, theTargetLabel?: string);
    /**
     * Precedence value. Default is `1`.
     */
    precedence: number;
    /**
     * Target label.
     */
    targetLabel: string;
}

/**
 * Defines a compartment of datum references or compartments.
 * Stores a collection of datum references or compartments and optionally a collection of modifiers, which is applied to each added compartment.
 */
export class ModelData_PMIDatumRefCompartmentAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMIDatumRefCompartmentAttribute.
     */
    constructor();
    /**
     * Number of added modifier attributes.
     */
    get numberOfModifierAttributes(): number;
    /**
     * Number of added references.
     */
    get numberOfReferences(): number;
    /**
     * Adds a modifier attribute.
     */
    addModifierAttribute(theAttribute: ModelData_PMIModifierAttribute): void;
    /**
     * Adds a reference.
     */
    addReference(theReference: ModelData_PMIDatumRefAttribute | ModelData_PMIDatumRefCompartmentAttribute): void;
    /**
     * Returns a specified modifier attribute.
     */
    modifierAttribute(theIndex: number): ModelData_PMIModifierAttribute | undefined;
    /**
     * Returns iterable to modifier attributes.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const modifierAttribute of attribute.modifierAttributes()) {
     *   // Access to the modifier attribute
     * }
     * ```
     */
    modifierAttributes(): Iterable<ModelData_PMIModifierAttribute>;
    /**
     * Returns a specified reference.
     */
    reference(theIndex: number): ModelData_PMISemanticAttribute | undefined;
    /**
     * Returns iterable to references.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const reference of attribute.modifierAttributes()) {
     *   // Access to the reference
     * }
     * ```
     */
    references(): Iterable<(ModelData_PMIDatumRefAttribute|ModelData_PMIDatumRefCompartmentAttribute)>;
}

/**
 * Defines a datum target data.
 * Contains a description (e.g. a point, line or limited area of the part surface) and an index (if the datum is composite).
 */
export class ModelData_PMIDatumTargetAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMIDatumTargetAttribute.
     */
    constructor(theIndex?: number, theDescription?: string);
    /**
     * The description.
     */
    description: string;
    /**
     * The index. Default is `1`.
     */
    index: number;
}

/**
 * Defines a component represented by a dimensional tolerance.
 * 
 * Dimensional tolerance has a nominal value and optionally additional attributes like modifiers, plus-minus bounds etc.
 * 
 * Examples of dimensional tolerance: dimensional size, dimensional location, angular size, etc.
 */
export class ModelData_PMIDimensionComponent extends ModelData_PMISemanticElementComponent {
    /**
     * Creates an instance of ModelData_PMIDimensionComponent.
     */
    constructor(theNominalValue?: number);
    /**
     * Nominal value of a dimension. Default is `0`.
     */
    nominalValue: number;
    /**
     * Type of dimension. Default is {@link ModelData_PMIDimensionType.Undefined}.
     */
    typeOfDimension: ModelData_PMIDimensionType;
}

/**
 * Defines type of dimensional tolerance.
 */
export enum ModelData_PMIDimensionType {
    Undefined = 0,
    CurveLength = 1,
    Diameter = 2,
    SphericalDiameter = 3,
    Radius = 4,
    SphericalRadius = 5,
    ToroidalMinorDiameter = 6,
    ToroidalMajorDiameter = 7,
    ToroidalMinorRadius = 8,
    ToroidalMajorRadius = 9,
    ToroidalHighMajorDiameter = 10,
    ToroidalLowMajorDiameter = 11,
    ToroidalHighMajorRadius = 12,
    ToroidalLowMajorRadius = 13,
    Thickness = 14,
}

/**
 * Defines a displacement value for an unequally disposed geometric tolerance.
 */
export class ModelData_PMIDisplacementAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMIDisplacementAttribute.
     */
    constructor(theDisplacement?: number);
    /**
     * Displacement value. Default is `0`.
     */
    displacement: number;
}

/**
 * Defines a component represented by a geometric tolerance.
 * 
 * Geometric tolerance has a magnitude and optionally additional attributes like modifiers, datum references, etc.
 * 
 * Examples of geometric tolerance: flatness tolerance, position tolerance, etc.
 */
export class ModelData_PMIGeometricToleranceComponent extends ModelData_PMISemanticElementComponent {
    /**
     * Creates an instance of ModelData_PMIGeometricToleranceComponent.
     */
    constructor(theMagnitude?: number);
    /**
     * Magnitude value of a tolerance.
     */
    magnitude: number;
    /**
     * Type of tolerance zone form.
     */
    toleranceZoneForm: ModelData_PMIGeometricToleranceZoneFormType;
}

/**
 * Defines type of tolerance zone form.
 */
export enum ModelData_PMIGeometricToleranceZoneFormType {
    Undefined = 0,
    CylindricalOrCircular = 1,
    Spherical = 2,
    WithinACircle = 3,
    BetweenTwoConcentricCircles = 4,
    BetweenTwoEquidistantCurves = 5,
    WithinACylinder = 6,
    BetweenTwoCoaxialCylinders = 7,
    BetweenTwoEquidistantSurfaces = 8,
    NonUniform = 9,
}

/**
 * Defines PMI graphical element type.
 * 
 * An element is complete elementary PMI entity such as dimension or tolerance measurement.
 * 
 * An element stores a presentation of PMI element or annotation in graphical form. The information
 * to be presented can be stored in different ways: outlines, text or triangulation. Therefore different
 * components ({@link ModelData_PMIGraphicalElementComponent} subclasses) were introduced to enable complete
 * description of element's graphical presentation.
 * 
 * An element contains components, plane, property table and its type.
 */
export class ModelData_PMIGraphicalElement extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_PMIGraphicalElement.
     */
    constructor(theName?: string);
    /**
     * Number of added components.
     */
    get numberOfComponents(): number;
    /**
     * The plane on which the 2d components are placed.
     */
    plane: ModelData_PMIPlane | null;
    /**
     * Accepts a component visitor.
     */
    accept(theVisitor: ModelData_PMIGraphicalElementComponentVisitor): void;
    /**
     * Adds a component.
     */
    addComponent(theComponent: ModelData_PMIGraphicalElementComponent): void;
    /**
     * Returns iterable to added components.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const component of graphicalElement.components()) {
     *   // Access to the component
     * }
     * ```
     * 
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___p_m_i_graphical_element_1_1_component_iterator.html ModelData_PMIGraphicalElement::ComponentIterator} class.
     */
    components(): Iterable<ModelData_PMIGraphicalElementComponent>;
    /**
     * Returns `true` if no graphical element components were added.
     */
    isEmpty(): boolean;
}

/**
 * Base class for various component types.
 */
export class ModelData_PMIGraphicalElementComponent {
    /**
     * Accepts a visitor.
     */
    accept(theVisitor: ModelData_PMIGraphicalElementComponentVisitor): void;
}

/**
 * Defines a visitor of the components.
 */
export abstract class ModelData_PMIGraphicalElementComponentVisitor {
    abstract visitOutlinedComponent(theComponent: ModelData_PMIOutlinedComponent): void;
    abstract visitTextComponent(theComponent: ModelData_PMITextComponent): void;
    abstract visitTriangulatedComponent(theComponent: ModelData_PMITriangulatedComponent): void;
}

/**
 * Defines a length unit.
 */
export class ModelData_PMILengthUnitAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMILengthUnitAttribute.
     */
    constructor(theUnit?: Base_LengthUnit);
    /**
     * Length unit. Default is {@link Base_LengthUnit Base_LU_Millimeters}.
     */
    unit: Base_LengthUnit;
}

/**
 * Defines a kind of a tolerance class dimension such as form variance, zone variance, grade, etc. (ISO 286)
 */
export class ModelData_PMILimitsAndFitsAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMILimitsAndFitsAttribute.
     */
    constructor(theType?: string, theValue?: string);
    /**
     * Attribute type.
     */
    type: string;
    /**
     * Attribute value.
     */
    value: string;
}

/**
 * Defines a maximum value.
 */
export class ModelData_PMIMaximumValueAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMIMaximumValueAttribute.
     */
    constructor(theMaxValue?: number);
    /**
     * Maximum value. Default is `0`.
     */
    maxValue: number;
}

/**
 * Defines the type of modification applied to a dimensional/geometric tolerance or a datum reference (e.g. statistical, free state, maximum material requirement, etc.).
 */
export class ModelData_PMIModifierAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMIModifierAttribute.
     */
    constructor(theModifier?: string);
    /**
     * Modifier name.
     */
    modifier: string;
}

/**
 * Defines the type of modification applied to a tolerance with additional value (e.g. minor diameter, etc.).
 */
export class ModelData_PMIModifierWithValueAttribute extends ModelData_PMIModifierAttribute {
    /**
     * Creates an instance of ModelData_PMIModifierWithValueAttribute.
     */
    constructor(theModifier?: string, theValue?: number);
    /**
     * Modifier name. Default is `0`.
     */
    value: number;
}

/**
 * Base class for various outline types.
 */
export class ModelData_PMIOutline {
    /**
     * Accepts a visitor.
     */
    accept(theVisitor: ModelData_PMIOutlineVisitor): void;
}

/**
 * Defines a visitor of the outlines.
 * 
 * Method {@link ModelData_PMIOutlineVisitor#visitCompositeOutlineEnter visitCompositeOutlineEnter()} returns `true`
 * if the child outlines of the composite outline should be visited.
 * If the method returns `false` then they will not be visited.
 * The method {@link ModelData_PMIOutlineVisitor#visitCompositeOutlineLeave visitCompositeOutlineLeave()} will always be called.
 */
export abstract class ModelData_PMIOutlineVisitor {
    abstract visitCompositeOutlineEnter(theOutline: ModelData_PMICompositeOutline): boolean;
    abstract visitCompositeOutlineLeave(theOutline: ModelData_PMICompositeOutline): void;
    abstract visitCurve2dOutline(theOutline: ModelData_PMICurve2dOutline): void;
    abstract visitCurveOutline(theOutline: ModelData_PMICurveOutline): void;
    abstract visitPoly2dOutline(theOutline: ModelData_PMIPoly2dOutline): void;
    abstract visitPolyOutline(theOutline: ModelData_PMIPolyOutline): void;
}

/**
 * Defines a component represented by outline.
 * 
 * A component stores PMI graphical data expressed by outline(s), like: unfilled text, lines, frames, arrows, etc.
 * 
 * The 2d elements of a component are defined by coordinates in the plane of its parent graphical element.
 */
export class ModelData_PMIOutlinedComponent extends ModelData_PMIGraphicalElementComponent {
    /**
     * Creates an instance of ModelData_PMIOutlinedComponent.
     */
    constructor(theOutline?: ModelData_PMIOutline | null);
    /**
     * Associated outline.
     */
    outline: ModelData_PMIOutline | null;
}

/**
 * Defines a plane where 2d graphical elements should be placed.
 * 
 * A plane allows to position 2d graphical data on the screen.
 * A plane can be attached to graphical element. But note that it only makes sense in case
 * where element contains 2d data or text.
 * 
 * > __Note__: The plane used by graphical element should be present in its table.
 */
export class ModelData_PMIPlane extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_PMITable.
     */
    constructor(thePlane?: ModelData_Plane | null, theName?: string);
    /**
     * A geometrical plane.
     */
    get plane(): ModelData_Plane | null;
}

/**
 * Defines a plus and minus bounds (deviations) of a tolerance.
 */
export class ModelData_PMIPlusMinusBoundsAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMIPlusMinusBoundsAttribute.
     */
    constructor(theLowerBound?: number, theUpperBound?: number);
    /**
     * Returns upper bound. Default is `0`.
     */
    lowerBound: number;
    /**
     * Returns lower bound. Default is `0`;
     */
    upperBound: number;
}

/**
 * Defines an outline consist of polylines.
 */
export class ModelData_PMIPoly2dOutline extends ModelData_PMIOutline {
    /**
     * Creates an instance of ModelData_PMIPoly2dOutline.
     */
    constructor(theLineSet?: ModelData_PolyLine2dSet);
    lineSet: ModelData_PolyLine2dSet | null;
}

/**
 * Defines an outline consist of polylines.
 */
export class ModelData_PMIPolyOutline extends ModelData_PMIOutline {
    /**
     * Creates an instance of ModelData_PMIPolyOutline.
     */
    constructor(theLineSet?: ModelData_PolyLineSet | null);
    lineSet: ModelData_PolyLineSet | null;
}

/**
 * Defines the type of qualifier that can limit a tolerance (e.g. max, min, etc.).
 */
export class ModelData_PMIQualifierAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMIQualifierAttribute.
     */
    constructor(theQualifier?: string);
    qualifier: string;
}

/**
 * Defines range of value.
 */
export class ModelData_PMIRangeAttribute extends ModelData_PMISemanticAttribute {
    /**
     * Creates an instance of ModelData_PMIRangeAttribute.
     */
    constructor(theLowerLimit?: number, theUpperLimit?: number);
    /**
     * Lower limit. Default is `0`.
     */
    lowerLimit: number;
    /**
     * Upper limit. Default is `0`.
     */
    upperLimit: number;
}

/**
 * Defines a view orientation of the model and a subset of visible PMI elements.
 * 
 * A saved view facilitates presentation of the model and its annotation.
 * It defines a set of elements that should be visible from the specific point of view.
 * 
 * A saved view contains graphical elements and camera.
 */
export class ModelData_PMISavedView extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_PMISavedView.
     */
    constructor(theCamera?: ModelData_PMICamera, theName?: string);
    camera: ModelData_PMICamera | null;
    /**
     * Number of added graphical elements.
     */
    get numberOfGraphicalElements(): number;
    /**
     * Adds a graphical element.
     */
    addGraphicalElement(theElement: ModelData_PMIGraphicalElement): void;
    /**
     * Returns a specified element.
     */
    graphicalElement(theIndex: number): ModelData_PMIGraphicalElement | undefined;
    /**
     * Returns iterable to outlines.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const element of savedView.graphicalElement()) {
     *   // Access to the element
     * }
     * ```
     * 
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___p_m_i_saved_view.html ModelData_PMISavedView::GraphicalElementIterator} class.
     */
    graphicalElements(): Iterable<ModelData_PMIGraphicalElement>;
}

/**
 * Base class for various attribute types.
 */
export abstract class ModelData_PMISemanticAttribute extends ModelData_BaseObject {
    accept(theVisitor: ModelData_PMISemanticAttributeVisitor): void;
}

/**
 * Defines a visitor of the attributes.
 */
export abstract class ModelData_PMISemanticAttributeVisitor {
    abstract visitAngleUnitAttribute(theAttribute: ModelData_PMIAngleUnitAttribute): void;
    abstract visitDatumRefAttribute(theAttribute: ModelData_PMIDatumRefAttribute): void;
    abstract visitDatumRefCompartmentAttribute(theAttribute: ModelData_PMIDatumRefCompartmentAttribute): void;
    abstract visitDatumTargetAttribute(theAttribute: ModelData_PMIDatumTargetAttribute): void;
    abstract visitDisplacementAttribute(theAttribute: ModelData_PMIDisplacementAttribute): void;
    abstract visitLengthUnitAttribute(theAttribute: ModelData_PMILengthUnitAttribute): void;
    abstract visitLimitsAndFitsAttribute(theAttribute: ModelData_PMILimitsAndFitsAttribute): void;
    abstract visitMaximumValueAttribute(theAttribute: ModelData_PMIMaximumValueAttribute): void;
    abstract visitModifierAttribute(theAttribute: ModelData_PMIModifierAttribute): void;
    abstract visitModifierWithValueAttribute(theAttribute: ModelData_PMIModifierWithValueAttribute): void;
    abstract visitPlusMinusBoundsAttribute(theAttribute: ModelData_PMIPlusMinusBoundsAttribute): void;
    abstract visitQualifierAttribute(theAttribute: ModelData_PMIQualifierAttribute): void;
    abstract visitRangeAttribute(theAttribute: ModelData_PMIRangeAttribute): void;
}

/**
 * Defines PMI semantic element type.
 * 
 * The ModelData_PMISemanticElement class stores a presentation of PMI entity in semantic form.
 * The stored information may be annotations associated with a CAD model's edges and faces such as dimensional/geometric tolerances or datum features.
 * Like graphical element semantic element may consists of several components ({@link ModelData_PMISemanticElementComponent} subclasses) each one representing specific semantic notation.
 */
export class ModelData_PMISemanticElement extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_PMISemanticElement.
     */
    constructor(theName?: string);
    /**
     * Number of added components.
     */
    get numberOfComponents(): number;
    /**
     * Adds a component.
     */
    addComponent(theComponent: ModelData_PMISemanticElementComponent): void;
    /**
     * Returns iterable to added components.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const component of semanticElement.components()) {
     *   // Access to the component
     * }
     * ```
     * 
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___p_m_i_semantic_element_1_1_component_iterator.html ModelData_PMISemanticElement::ComponentIterator} class.
     */
    components(): Iterable<ModelData_PMISemanticElementComponent>;
    /**
     * Returns `true` if no semantic element components were added.
     */
    isEmpty(): boolean;
}

/**
 * Base class for various component types.
 */
export class ModelData_PMISemanticElementComponent extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_PMISemanticElementComponent.
     */
    constructor();
    /**
     * Number of added attributes.
     */
    get numberOfAttributes(): number;
    /**
     * Accepts a visitor.
     */
    accept(theVisitor: ModelData_PMISemanticElementComponentVisitor): void;
    /**
     * Accepts an attribute visitor.
     */
    acceptAttributeVisitor(theVisitor: ModelData_PMISemanticAttributeVisitor): void;
    /**
     * Adds an attribute.
     */
    addAttribute(theAttribute: ModelData_PMISemanticAttribute): void;
    /**
     * Returns iterable to added attributes.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const attribute of semanticElementComponent.attributes()) {
     *   // Access to the attribute
     * }
     * ```
     * 
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___p_m_i_semantic_element_component_1_1_attribute_iterator.html ModelData_PMISemanticElementComponent::AttributeIterator} class.
     */
    attributes(): Iterable<ModelData_PMISemanticAttribute>;
    /**
     * Returns `true` if semantic attributes were added and `false` otherwise.
     */
    hasAttributes(): boolean;
}

/**
 * Defines a visitor of the components.
 */
export abstract class ModelData_PMISemanticElementComponentVisitor {
    abstract visitDatumComponent(theComponent: ModelData_PMIDatumComponent): void;
    abstract visitDimensionComponent(theComponent: ModelData_PMIDimensionComponent): void;
    abstract visitGeometricToleranceComponent(theComponent: ModelData_PMIGeometricToleranceComponent): void;
}

/**
 * Defines a container storing PMI data.
 * 
 * A table stores PMI specific information.
 * 
 * A table can be attached to any scene graph element ({@link ModelData_SceneGraphElement} subclass).
 */
export class ModelData_PMITable extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_PMITable.
     */
    constructor(theName?: string);
    /**
     * Number of PMI planes.
     */
    get numberOfPlanes(): number;
    /**
     * Number of added PMI data objects.
     */
    get numberOfPMIData(): number;
    /**
     * The number of Saved View objects.
     */
    get numberOfSavedViews(): number;
    /**
     * Adds a graphical element.
     */
    add(theData: ModelData_PMIData): void;
    /**
     * Adds a plane.
     */
    addPlane(thePlane: ModelData_PMIPlane): void;
    /**
     * Adds PMI table provider.
     */
    addProvider(theProvider: ModelData_PMITableProvider): void;
    /**
     * Appends a collection of PMI entities.
     */
    addTable(theTable: ModelData_PMITable): void;
    /**
     * Adds a saved view.
     */
    addView(theView: ModelData_PMISavedView): void;
    /**
     * Clear all data in the PMI table.
     */
    clear(): void;
    /**
     * Returns `true` if no PMI items or providers have been added.
     */
    isEmpty(): boolean;
    /**
     * Returns list of saved view.
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___p_m_i_table.html ModelData_PMITable::PlaneIterator} class.
     */
    planes(theScope?: Base_ProgressScope): Promise<ReadonlyArray<ModelData_PMIPlane>>;
    /**
     * Returns list of graphical elements.
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___p_m_i_table.html ModelData_PMITable::PMIDataIterator} class.
     */
    pmiDataItems(theScope?: Base_ProgressScope): Promise<ReadonlyArray<ModelData_PMIData>>;
    /**
     * Returns list of saved view.
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___p_m_i_table.html ModelData_PMITable::SavedViewIterator} class.
     */
    views(theScope?: Base_ProgressScope): Promise<ReadonlyArray<ModelData_PMISavedView>>;
}

/**
 * Provides {@link ModelData_PMITable PMI table}.
 * 
 * Used to defer population of the PMI data and thereby to reduce peak memory footprint.
 */
export abstract class ModelData_PMITableProvider {
    /**
     * Feeds the PMI table.
     * This method can depend of the network requests which makes asynchronously, so returns Promise.
     * Subclasses must redefine this method to call {@link ModelData_PMITable#add add()} of thePMITable.
     */
    abstract feed(thePMITable: ModelData_PMITable, theScope: Base_ProgressScope): Promise<void>;
}

/**
 * Defines a component represented by text.
 * 
 * A component stores PMI graphical data expressed by a string.
 * 
 * A component contains text and outline. Outline is optional and may be used as fallback,
 * when target format doesn't support PMI text entities. It also may be used for fast screen rendering.
 * 
 * The elements of a component are defined by coordinates in the plane of its parent graphical element.
 */
export class ModelData_PMITextComponent extends ModelData_PMIGraphicalElementComponent {
    /**
     * Creates an instance of ModelData_PMITextComponent.
     */
    constructor();
    /**
     * Size of the font. Default is `16`.
     */
    fontSize: number;
    /**
     * Outline for text. Default is `null`.
     */
    outline: ModelData_PMIOutline | null;
    /**
     * Text to display. Default is `null`.
     */
    text: string | null;
    /**
     * Coordinates in the plane. Default is `(0, 0)`.
     */
    textOrigin: ModelData_Point2d;
}

/**
 * Defines a component represented by triangulation.
 * 
 * A component stores PMI graphical data expressed by triangulation,
 * like filled text or any other triangulated planar shape.
 * 
 * A component contains indexed triangle set.
 */
export class ModelData_PMITriangulatedComponent extends ModelData_PMIGraphicalElementComponent {
    /**
     * Creates an instance of ModelData_PMITriangulatedComponent.
     */
    constructor(theTriangleSet?: ModelData_IndexedTriangleSet);
    triangleSet: ModelData_IndexedTriangleSet | null;
}

/**
 * Defines a PMI graphical element type.
 */
export enum ModelData_PMIType {
    Note = 0,
    Dimension = 1,
    Tolerance = 2,
    CoordinateSystem = 3,
    CenterLine = 4,
    ReferenceGeometry = 5,
    MeasurementPoint = 6,
    Datum = 7,
    FeatureControlFrame = 8,
    Weld = 9,
    SurfaceFinish = 10,
    Section = 11,
    Undefined = 1000,
    UserDefined = 1001,
}

/**
 * Defines a 3D point.
 */
export class ModelData_Point {
    /**
     * Creates an instance of ModelData_Point.
     */
    constructor(x?: number, y?: number, z?: number);
    /**
     * A tolerance to compare coincidence of two points.
     */
    static readonly coincidenceTolerance: number;
    /**
     * X coord.
     */
    get x(): number;
    set x(x: number);
    /**
     * Y coord.
     */
    get y(): number;
    set y(y: number);
    /**
     * Z coord.
     */
    get z(): number;
    set z(z: number);
    /**
     * Creates point from object implementing {@link ModelData_XYZ} interface.
     */
    static fromXYZ(theXYZ: ModelData_XYZ): ModelData_Point;
    /**
     * Adds point to current.
     */
    add(thePoint: ModelData_XYZ): this;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Point;
    /**
     * Copies values from another point.
     */
    copy(thePoint: ModelData_XYZ): this;
    /**
     * Returns distance between current point and other point.
     * 
     * > __Note__: Method uses Math.Sqrt() what may incur performance penalty,
     * so favor using `squareDistance` method in performance-sensitive algorithms.
     */
    distance(thePoint: ModelData_XYZ): number;
    divideScalar(theScalar: number): this;
    fromArray(theArray: Array<number>, theOffset?: number): this;
    /**
     * Compares two points with specified tolerance.
     */
    isEqual(thePoint: ModelData_Point, theTolerance?: number): boolean;
    /**
     * Multiplies point by scalar.
     */
    multiplyScalar(theScalar: number): this;
    /**
     * Sets coordinates.
     */
    setCoord(x: number, y: number, z: number): this;
    /**
     * Returns square distance between current point and other point.
     */
    squareDistance(theOther: ModelData_XYZ): number;
    /**
     * Subtracts point from current.
     */
    sub(thePoint: ModelData_XYZ): this;
    /**
     * Returns JSON representation of the point.
     */
    toJSON(): ModelData_XYZ;
    /**
     * Returns string representation of the point.
     */
    toString(): string;
    /**
     * Transforms the point with a transformation matrix.
     */
    transform(theTransformation: ModelData_Transformation): this;
    /**
     * Returns a new point which is transformed with a transformation matrix.
     */
    transformed(theTransformation: ModelData_Transformation): ModelData_Point;
    translate(theVector: ModelData_Vector): this;
    translated(theVector: ModelData_Vector): this;
}

/**
 * Represents point in 2D space.
 */
export class ModelData_Point2d {
    /**
     * Creates an instance of ModelData_Point2d.
     */
    constructor(x?: number, y?: number);
    /**
     * A tolerance to compare coincidence of two points.
     */
    static readonly coincidenceTolerance: number;
    /**
     * X coord.
     */
    get x(): number;
    set x(x: number);
    /**
     * Y coord.
     */
    get y(): number;
    set y(y: number);
    /**
     * Creates point from object implementing {@link ModelData_XY} interface.
     */
    static fromXY(theXY: ModelData_XY): ModelData_Point2d;
    /**
     * Adds point to current.
     */
    add(thePoint: ModelData_XY): this;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Point2d;
    /**
     * Copies values from another point.
     */
    copy(thePoint: ModelData_XY): this;
    /**
     * Returns distance between current point and other point.
     * 
     * > __Note__: Method uses Math.Sqrt() what may incur performance penalty,
     * so favor using `squareDistance` method in performance-sensitive algorithms.
     */
    distance(thePoint: ModelData_XY): number;
    fromArray(theArray: Array<number>, theOffset?: number): this;
    /**
     * Compares two points with specified tolerance.
     */
    isEqual(thePoint: ModelData_Point2d, theTolerance?: number): boolean;
    /**
     * Multiplies point by scalar.
     */
    multiplyScalar(theScalar: number): this;
    /**
     * Sets coordinates.
     */
    setCoord(x: number, y: number): this;
    /**
     * Returns square distance between current point and other point.
     */
    squareDistance(theOther: ModelData_XY): number;
    /**
     * Subtract point from current.
     */
    sub(thePoint: ModelData_XY): this;
    /**
     * Returns JSON representation of the point.
     */
    toJSON(): ModelData_XY;
    /**
     * Returns string representation of the point.
     */
    toString(): string;
    translate(theVector: ModelData_Vector2d): this;
}

/**
 * Defines a polygonal shape consisting of 2d polylines.
 */
export class ModelData_PolyLine2dSet extends ModelData_PolyVertex2dSet {
    /**
     * Number of poly lines.
     */
    get numberOfPolylines(): number;
    /**
     * Returns a coordinate index for a vertex in a line.
     */
    coordinateIndex(thePolyline: number, theVertexSlot: number): number;
    /**
     * Returns a number of vertices in polyline.
     */
    numberOfLineVertices(thePolyline: number): number;
}

/**
 * Defines a polygonal shape consisting of poly lines.
 */
export class ModelData_PolyLineSet extends ModelData_PolyVertexSet {
    /**
     * Number of poly lines.
     */
    get numberOfPolylines(): number;
    /**
     * Returns a coordinate index for a vertex in a line.
     */
    coordinateIndex(thePolyline: number, theVertexSlot: number): number;
    /**
     * Returns a number of vertices in polyline.
     */
    numberOfLineVertices(thePolyline: number): number;
}

/**
 * Defines a polygonal shape consisting of individual 2d points.
 */
export class ModelData_PolyPoint2dSet extends ModelData_PolyVertex2dSet {
}

/**
 * Defines a polygonal shape consisting of individual points.
 */
export class ModelData_PolyPointSet extends ModelData_PolyVertexSet {
}

/**
 * Defines polygonal (faceted or tessellated) representation of part.
 */
export class ModelData_PolyRepresentation extends ModelData_Representation {
    /**
     * Creates an instance of ModelData_PolyRepresentation.
     */
    constructor(theShape?: ModelData_PolyShape);
    /**
     * Adds a polygonal shape.
     */
    add(theShape: ModelData_PolyShape): void;
    /**
     * Adds Poly representations provider.
     */
    addProvider(theProvider: ModelData_PolyRepresentationProvider): void;
    /**
     * Returns Promise for list of shapes. This method flushes providers.
     */
    polyShapeList(theScope?: Base_ProgressScope): Promise<ModelData_PolyShapeList>;
}

/**
 * Provides {@link ModelData_PolyRepresentation polygonal representation}.
 * 
 * Used to defer construction of the polygonal representation and thereby to reduce peak memory footprint.
 */
export abstract class ModelData_PolyRepresentationProvider {
    /**
     * Feeds the representation.
     * This method can depend of the network requests which makes asynchronously, so it returns Promise.
     * Subclasses must redefine this method to call {@link ModelData_PolyRepresentation#add add()}
     * of theRepresentation.
     */
    abstract feed(theRepresentation: ModelData_PolyRepresentation, theScope: Base_ProgressScope): Promise<void>;
}

/**
 * Base class for polygonal meshes.
 */
export class ModelData_PolyShape extends ModelData_BaseObject {
}

/**
 * Base class for polygonal 2d shapes.
 */
export class ModelData_PolyShape2d extends ModelData_BaseObject {
}

/**
 * Defines a list of poly shapes.
 * Body list is used by ModelData_PolyRepresentation to hold root shapes.
 */
export class ModelData_PolyShapeList extends ModelData_PolyShape implements Iterable<ModelData_PolyVertexSet> {
    [Symbol.iterator](): Iterator<ModelData_PolyVertexSet>;
    /**
     * Adds body to the body list.
     */
    append(thePolyShape: ModelData_PolyShape): void;
    /**
     * Retrieve poly shape by index.
     */
    element(theIndex: number): ModelData_PolyVertexSet;
    /**
     * Returns the number of added poly shapes.
     */
    size(): number;
}

/**
 * Base class for particular 2d vertex sets - polyline sets, point sets.
 * 
 * The vertex set defines a set of vertex coordinates which is used by subclass.
 */
export class ModelData_PolyVertex2dSet extends ModelData_PolyShape2d {
    /**
     * Optional appearance assigned with poly vertex set.
     */
    appearance: ModelData_Appearance | null;
    /**
     * Array of colors in RGB ([R,G,B,R,G,B,...]) or RGBA [R,G,B,A,R,G,B,A,...] format.
     */
    colors: Float32Array | null;
    /**
     * Array of coords in {x,y,z} format [x,y,z,x,y,z,...].
     */
    coords: Float32Array | null;
    /**
     * Number of color elements.
     */
    get numberOfColors(): number;
    /**
     * Number of coord elements.
     */
    get numberOfVertices(): number;
    /**
     * Returns a color per its index.
     * 
     * > __Note__: changing returned object does not change original color.
     */
    color(theIndex: number, theTarget?: ModelData_ColorObject): ModelData_ColorObject | undefined;
    /**
     * Returns a vertex coordinate per its index.
     * 
     * > __Note__: changing returned object does not change original coord.
     */
    coordinate(theIndex: number, theTarget?: ModelData_Point2d): ModelData_Point2d | undefined;
    /**
     * Returns `true` if object has colors per vertex.
     */
    hasColors(): boolean;
}

/**
 * Base class for particular vertex sets - triangle sets, polyline sets, point sets.
 * 
 * The vertex set can optionally contain colors which are defined per each vertex.
 */
export abstract class ModelData_PolyVertexSet extends ModelData_PolyShape {
    /**
     * Creates an instance of ModelData_PolyVertexSet.
     */
    constructor();
    /**
     * Optional appearance assigned with poly vertex set.
     */
    appearance: ModelData_Appearance | null;
    /**
     * Array of colors in RGB ([R,G,B,R,G,B,...]) or RGBA [R,G,B,A,R,G,B,A,...] format.
     */
    colors: Float32Array | null;
    /**
     * Array of coords in {x,y,z} format [x,y,z,x,y,z,...].
     */
    coords: Float32Array | null;
    /**
     * Number of color elements.
     */
    get numberOfColors(): number;
    /**
     * Number of coord elements.
     */
    get numberOfVertices(): number;
    /**
     * Returns a color per its index.
     * 
     * > __Note__: changing returned object does not change original color.
     */
    color(theIndex: number, theTarget?: ModelData_ColorObject): ModelData_ColorObject | undefined;
    /**
     * Returns a vertex coordinate per its index.
     * 
     * > __Note__: changing returned object does not change original coord.
     */
    coordinate(theIndex: number, theTarget?: ModelData_Point): ModelData_Point | undefined;
    /**
     * Returns `true` if object has colors per vertex.
     */
    hasColors(): boolean;
}

/**
 * Defines primitives group with appearance.
 * 
 * > __Note__: the group always refers to appearance array item, which can have `undefined` value.
 */
export interface ModelData_PrimitivesGroup {
    /**
     * Index of appearance associated with current group.
     */
    appearanceIndex: number;
    /**
     * Number of elements in the group.
     */
    count: number;
    /**
     * Start index of the group.
     */
    start: number;
}

/**
 * Defines a collection of properties.
 * 
 * Property table is a list of pairs {property_name, property_value}. A property name is defined with a string.
 * A value can have any of the following types:
 * * number
 * * string
 * * timestamp
 * * 3D Point
 * * 3D Box
 * 
 * In addition, validation properties (surface area, volume, centroid, etc) can be registered using
 * reserved property names.
 * 
 * A property table can be attached to any scene graph element ({@link ModelData_SceneGraphElement ModelData_SceneGraphElement} subclass)
 * or a subshape in {@link ModelData_BRepRepresentation ModelData_BRepRepresentation}.
 * 
 * A property table can be checked with IsEmpty(), Size() and cleared with Clear() method.
 */
export class ModelData_PropertyTable extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_PropertyTable.
     */
    constructor(theName?: string);
    /**
     * Key to designate a 'bounding box' property.
     */
    static readonly BoundingBoxPropertyName: string;
    /**
     * Key to designate a 'centroid' validation property.
     */
    static readonly CentroidPropertyName: string;
    /**
     * Key to designate a 'name' property.
     */
    static readonly NamePropertyName: string;
    /**
     * Key to designate a 'surface area' validation property.
     */
    static readonly SurfaceAreaPropertyName: string;
    /**
     * Key to designate a 'volume' validation property.
     */
    static readonly VolumePropertyName: string;
    /**
     * Adds property to table.
     */
    add(theKey: string, theValue: string | number | Date | ModelData_Point | ModelData_Box): void;
    /**
     * Adds property table provider.
     */
    addProvider(theProvider: ModelData_PropertyTableProvider): void;
    /**
     * Appends properties from another property table.
     */
    addTable(thePropertyTable: ModelData_PropertyTable): void;
    /**
     * Discards associated data.
     * Providers which have been added with their deleters will be deleted.
     */
    clear(): void;
    /**
     * Returns `Promise` for property value. If property is not existed, the promise will be resolved with `undefined`.
     */
    findProperty(theName: string, theFlushProviders?: boolean): Promise<(string|number|Date|ModelData_Point|ModelData_Box|undefined)>;
    /**
     * Returns `true` if no property items or providers have been added.
     */
    isEmpty(): boolean;
    /**
     * Returns dictionary object. Keys are properties names, values are properties values.
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___property_table.html ModelData_PropertyTable::Accept()} method.
     */
    properties(theScope?: Base_ProgressScope): Promise<Record<string, (string|number|Date|ModelData_Point|ModelData_Box)>>;
    /**
     * Returns the number of added properties.
     */
    size(): number;
}

/**
 * Provides properties to the {@link ModelData_PropertyTable property table}.
 * 
 * Used to defer population of the properties and thereby to reduce peak memory footprint.
 */
export abstract class ModelData_PropertyTableProvider {
    /**
     * Feeds the property table.
     * This method can depend of the network request which makes asynchronously, so it should return Promise.
     * Subclasses must redefine this method to call {@link ModelData_PropertyTable#add add()} of theTable.
     */
    abstract feed(theTable: ModelData_PropertyTable, theScope: Base_ProgressScope): Promise<void>;
}

/**
 * A ray that emits from an origin in a certain direction.
 */
export class ModelData_Ray {
    /**
     * Creates an instance of ModelData_Ray.
     */
    constructor(theOrigin?: ModelData_XYZ, theDirection?: ModelData_XYZ);
    /**
     * Ray direction.
     */
    get direction(): ModelData_Direction;
    /**
     * Ray origin.
     */
    get origin(): ModelData_Point;
}

/**
 * Base class for all representations.
 */
export class ModelData_Representation extends ModelData_BaseObject {
    /**
     * Accepts a representation visitor.
     */
    accept(theVisitor: ModelData_RepresentationVisitor): Promise<void>;
}

/**
 * Defines a visitor of the representations.
 * This visitor corresponds to the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___part.html ModelData_Part::RepresentationVisitor} class.
 */
export abstract class ModelData_RepresentationVisitor {
    abstract visitBRepRepresentation(theBRepRep: ModelData_BRepRepresentation): Promise<void> | void;
    abstract visitPolyRepresentation(thePolyRep: ModelData_PolyRepresentation): Promise<void> | void;
}

/**
 * Defines a mask to filter part representations.
 */
export enum ModelData_RepresentationMask {
    /**
     * Filter only B-Rep representation.
     */
    ModelData_RM_BRep = 1,
    /**
     * Filter coarse Poly representation.
     */
    ModelData_RM_CoarseLOD = 16,
    /**
     * Filter medium Poly representation.
     */
    ModelData_RM_MediumLOD = 32,
    /**
     * Filter fine Poly representation.
     */
    ModelData_RM_FineLOD = 64,
    /**
     * Filter any Poly representation.
     */
    ModelData_RM_Poly = 112,
    /**
     * Filter any representation.
     */
    ModelData_RM_Any = 113,
}

/**
 * Base class for part, instance and assembly.
 */
export class ModelData_SceneGraphElement extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_SceneGraphElement.
     */
    constructor();
    /**
     * Appearance of the element.
     * 
     * > __Note:__ By convention assemblies may not have appearances.
     * If one is set using this function it can be ignored by other CAD Exchanger functions (e.g. export).
     */
    appearance: ModelData_Appearance | null;
    /**
     * PMI table of the element.
     */
    get pmi(): ModelData_PMITable | null;
    /**
     * Property table of the element.
     */
    get properties(): ModelData_PropertyTable | null;
    /**
     * Accepts an element visitor.
     * 
     * The order of visiting depends on the type of this object:
     * 
     * * for a part invokes a visitor for the part ({@link ModelData_SceneGraphElementVisitor#visitPart visitPart()});
     * 
     * * for an instance first enters the instance by calling
     * {@link ModelData_SceneGraphElementVisitor#visitInstanceEnter visitInstanceEnter()}.
     * If it returns `true` then visits the referred element. Then leaves the instance calling
     * {@link ModelData_SceneGraphElementVisitor#visitInstanceLeave visitInstanceLeave()}.
     * 
     * * for an assembly first enters the assembly by calling
     * {@link ModelData_SceneGraphElementVisitor#visitAssemblyEnter visitAssemblyEnter()}.
     * If it returns `true` then visits all the assembly children. Then leaves the assembly calling
     * {@link ModelData_SceneGraphElementVisitor#visitAssemblyLeave visitAssemblyLeave()}.
     */
    accept(theVisitor: ModelData_SceneGraphElementVisitor): Promise<void>;
    /**
     * Adds a PMI table to the element.
     * 
     * If this object did not have PMI yet, then thePMI are just linked to this object.
     * Otherwise, the elements of thePMI are appended to existing PMI table
     * (see {@link ModelData_PMITable#add ModelData_PMITable#add()}).
     */
    addPMI(thePMI: ModelData_PMITable): void;
    /**
     * Adds a property table to the element.
     * If this object did not have properties yet, then theProperties are just linked to this object.
     * Otherwise, the elements of theProperties are appended to existing property table
     * (see {@link ModelData_PropertyTable#add ModelData_PropertyTable#add()} method).
     */
    addProperties(theProperties: ModelData_PropertyTable): void;
}

/**
 * Defines a visitor of the scene graph elements.
 * This visitor corresponds to the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___model_1_1_void_element_visitor.html ModelData_Model::VoidElementVisitor} class.
 * 
 * The Visitor follows a hierarchical visitor pattern (see
 * http://c2.com/cgi/wiki?HierarchicalVisitorPattern) what enables to track entering
 * and leaving composite entities - assemblies and instances.
 * 
 * Methods visitInstanceEnter() and visitAssemblyEnter() returns Promise resolved to `true` if the child elements
 * of the assembly or a referred element of the instance should be visited.
 * If the method returns Promise resolved to `false` they will not be visited.
 * The methods `visitInstanceLeave()` and `visitAssemblyEnter()` will always be called.
 */
export abstract class ModelData_SceneGraphElementVisitor {
    abstract visitAssemblyEnter(theAssembly: ModelData_Assembly): Promise<boolean> | boolean;
    abstract visitAssemblyLeave(theAssembly: ModelData_Assembly): Promise<void> | void;
    abstract visitInstanceEnter(theInstance: ModelData_Instance): Promise<boolean> | boolean;
    abstract visitInstanceLeave(theInstance: ModelData_Instance): Promise<void> | void;
    abstract visitPart(thePart: ModelData_Part): Promise<void> | void;
}

/**
 * Base class of topological shapes.
 * 
 * Topological shapes define boundaries of the geometrical entities (curves and surfaces) in
 * {@link ModelData_BRepRepresentation B-Rep representation}.
 * 
 * Some topological entities refer to geometrical entities (e.g. edge refers to curve and
 * face refers to surface), whereas some only refer to child topological entities (e.g. wire refers.
 * to edges it consists of or shell refers to faces it consists of).
 * 
 * Children subshapes can be retrieved using {@link ModelData_ShapeIterator Iterator}.
 */
export class ModelData_Shape implements Iterable<ModelData_Shape> {
    /**
     * Shape type.
     */
    get type(): ModelData_ShapeType;
    [Symbol.iterator](): Iterator<ModelData_Shape>;
}

/**
 * Iterates over subshapes in a shape.
 * 
 * Iterator supports two usage scenario:
 * * iteration over direct children;
 * * iteration over subshapes of a specified type.
 * 
 * To retrieve direct children of a shape, `ModelData_ShapeIterator` should be used as follows:
 * 
 * <span class="doxygen-js"></span>
 * ```js
 * const aWire = ...;
 * for (val aChild of new ModelData_ShapeIterator (aWire)) {
 *   const aType = aChild.type;
 * }
 * ```
 * 
 * To retrieve children of a particular type, `ModelData_ShapeIterator` should be used by specifying
 * a type of interest as follows:
 * 
 * <span class="doxygen-js"></span>
 * ```js
 * const aSolid = ...;
 * for (val aChild of new ModelData_ShapeIterator (aSolid, ModelData_ShapeType.Edge)) {
 *   // "aChild" has ModelData_Edge type
 *   // For typescript cast to ModelData_Edge:
 *   // const anEdge = aChild as ModelData_Edge;
 * }
 * ```
 * 
 * When using the latter approach exploration is done traversing the graph of subshapes in a depth-first manner.
 * Each subshape will be found as many times as it is registered in the parent subshape.
 * For instance, a seam-edge will be encountered twice, with forward and reversed orientations.
 * 
 * The order of returned subshapes is deterministic and corresponds to the order
 * in which the subshapes were added during construction.
 * 
 * This class corresponds to the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___shape_1_1_iterator.html ModelData_Shape::Iterator} class
 * and implements {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols JS iteration protocols}.
 */
export class ModelData_ShapeIterator implements Iterable<ModelData_Shape> {
    /**
     * Creates an instance of ModelData_ShapeIterator.
     */
    constructor(theShape: ModelData_Shape, theType?: ModelData_ShapeType);
    [Symbol.iterator](): Iterator<ModelData_Shape>;
}

/**
 * Defines shape type.
 */
export enum ModelData_ShapeType {
    BodyList = 0,
    Body = 1,
    Solid = 2,
    Shell = 3,
    Face = 4,
    Wire = 5,
    Edge = 6,
    Vertex = 7,
    Undefined = 8,
}

/**
 * Defines a connected set of faces.
 */
export class ModelData_Shell extends ModelData_Shape {
    /**
     * Creates an instance of ModelData_Shell.
     */
    constructor(theFace?: ModelData_Face);
    /**
     * Adds a face to the shell.
     */
    append(theFace: ModelData_Face): boolean;
    [Symbol.iterator](): Iterator<ModelData_Face>;
}

/**
 * Defines a topological solid.
 * 
 * As a rule, a solid has a single external shell.
 * Solids with voids (i.e. multiple shells) are also supported.
 */
export class ModelData_Solid extends ModelData_Shape {
    /**
     * Creates an instance of ModelData_Solid.
     */
    constructor(theShell?: ModelData_Shell);
    [Symbol.iterator](): Iterator<ModelData_Shell>;
    /**
     * Adds a shell to the solid.
     */
    append(theShell: ModelData_Shell): boolean;
}

/**
 * Base class for geometrical surfaces.
 * 
 * Surfaces in 3D space are used to represent boundaries of a body (e.g. solid or sheet body).
 * Each {@link ModelData_Face "face"} must refer to a surface.
 * 
 * > __Note__: This class is defined for SDK API compatibility only.
 * Unlike {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___surface.html C++ SDK Surface}
 * it contains only type of the surface.
 */
export class ModelData_Surface {
    /**
     * Surface type.
     */
    get type(): ModelData_SurfaceType;
}

/**
 * Defines surface type.
 */
export enum ModelData_SurfaceType {
    Plane = 0,
    Cylinder = 1,
    Cone = 2,
    Sphere = 3,
    Torus = 4,
    LinearExtrusion = 5,
    Revolution = 6,
    Bezier = 7,
    BSpline = 8,
    Offset = 9,
    Trimmed = 10,
    Undefined = 100,
    UserDefined = 101,
}

/**
 * Provides an interface to the 2D texture.
 */
export class ModelData_Texture extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_Texture.
     */
    constructor(theTextureType?: ModelData_TextureType, theTextureParameters?: ModelData_TextureParameters | null);
    /**
     * Texture parameters.
     */
    parameters: ModelData_TextureParameters;
    /**
     * Texture type. Default is {@link ModelData_TextureType.ModelData_TT_Unknown ModelData_TT_Unknown}.
     */
    type: ModelData_TextureType;
    /**
     * Accepts a texture visitor.
     */
    accept(theVisitor: ModelData_TextureVisitor): Promise<void>;
    /**
     * Equality operator.
     * Returns `true` if type and all parameters of two textures are equal.
     */
    isEqual(theTexture: ModelData_Texture | null | undefined): boolean;
}

/**
 * Texture blending mode.
 */
export enum ModelData_TextureBlendMode {
    ModelData_TBM_Decal = 0,
    ModelData_TBM_Modulate = 1,
    ModelData_TBM_Replace = 2,
}

/**
 * Texture magnification filter.
 */
export enum ModelData_TextureMagnificationFilter {
    ModelData_TMagF_Nearest = 0,
    ModelData_TMagF_Linear = 1,
}

/**
 * Texture mapping mode.
 */
export enum ModelData_TextureMappingMode {
    ModelData_TMM_UVMapping = 0,
    ModelData_TMM_SphereMapping = 1,
}

/**
 * Texture minification filter.
 */
export enum ModelData_TextureMinificationFilter {
    ModelData_TMinF_Nearest = 0,
    ModelData_TMinF_NearestMipMapNearest = 1,
    ModelData_TMinF_NearestMipMapLinear = 2,
    ModelData_TMinF_Linear = 3,
    ModelData_TMinF_LinearMipMapNearest = 4,
    ModelData_TMinF_LinearMipMapLinear = 5,
}

/**
 * Provides an interface to set of textures.
 */
export class ModelData_TextureParameters extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_Texture.
     */
    constructor();
    /**
     * A blending mode describes how to mix texture colors. Should be one of {@link ModelData_TextureBlendMode ModelData_TextureBlendMode}.
     * Default value is ModelData_TextureBlendMode.ModelData_TBM_Decal.
     */
    blendMode: ModelData_TextureBlendMode;
    /**
     * Indicates to generate mipmaps (if possible) for a texture or not.
     * Default value is true.
     */
    generateMipmaps: boolean;
    /**
     * A magnification filter which indicates how the texture is sampled when a texel covers more than one pixel.
     * Should be one of {@link ModelData_TextureMagnificationFilter ModelData_TextureMagnificationFilter}.
     * Default value is ModelData_TextureMagnificationFilter.ModelData_TMagF_Linear,
     * which takes the four closest texels and bilinearly interpolates among them.
     */
    magnificationFilter: ModelData_TextureMagnificationFilter;
    /**
     * A mapping mode describes how to calculate textures coords. Should be one of {@link ModelData_TextureMappingMode ModelData_TextureMappingMode}.
     * Default value is ModelData_TextureMappingMode.ModelData_TMM_UVMapping.
     */
    mappingMode: ModelData_TextureMappingMode;
    /**
     * A minification filter which indicates how the texture is sampled when a texel covers less than one pixel.
     * Should be one of {@link ModelData_TextureMinificationFilter ModelData_TextureMinificationFilter}.
     * Default value is ModelData_TextureMinificationFilter.ModelData_TMinF_LinearMipMapLinear,
     * which uses mipmapping and a trilinear filter.
     */
    minificationFilter: ModelData_TextureMinificationFilter;
    /**
     * A rotation is describe angle to rotate texture coords to.
     * Default value is 0.
     */
    rotation: number;
    /**
     * A scale applied to the texture width.
     * Default value is 1.
     */
    scaleU: number;
    /**
     * A scale applied to the texture height.
     * Default value is 1.
     */
    scaleV: number;
    /**
     * A translation which indicates how much a single repetition of the texture is offset from the beginning in U direction.
     * Default value is 0.
     */
    translationU: number;
    /**
     * A translation which indicates how much a single repetition of the texture is offset from the beginning in V direction.
     * Default value is 0.
     */
    translationV: number;
    /**
     * A wrap mode which defines how the texture is wrapped horizontally and corresponds to U in UV mapping.
     * Should be one of {@link ModelData_TextureWrapMode ModelData_TextureWrapMode}.
     * Default value is ModelData_TextureWrapMode.ModelData_TWM_Repeat.
     */
    wrapModeU: ModelData_TextureWrapMode;
    /**
     * A wrap mode which defines how the texture is wrapped horizontally and corresponds to V in UV mapping.
     * Should be one of {@link ModelData_TextureWrapMode ModelData_TextureWrapMode}.
     * Default value is ModelData_TextureWrapMode.ModelData_TWM_Repeat.
     */
    wrapModeV: ModelData_TextureWrapMode;
    /**
     * Equality operator.
     * Returns `true` if all values of two texture parameters are equal.
     */
    isEqual(theOther: ModelData_TextureParameters | null | undefined): boolean;
}

/**
 * Provides an interface to set of textures.
 */
export class ModelData_TextureSet extends ModelData_BaseObject {
    /**
     * Creates an instance of ModelData_TextureSet.
     */
    constructor();
    /**
     * Number of textures in texture set.
     */
    get numberOfTextures(): number;
    /**
     * Accepts a texture visitor.
     */
    accept(theVisitor: ModelData_TextureVisitor): Promise<void>;
    /**
     * Adds texture to texture set.
     * 
     * Returns `true` if insertion was successfully.
     */
    add(theTexture: ModelData_Texture): boolean;
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_TextureSet;
    combineWith(theOther: ModelData_TextureSet): void;
    /**
     * Checks texture to be in texture set.
     */
    contains(theTexture: ModelData_Texture): boolean;
    /**
     * Copies data from another texture set.
     */
    copy(theTextureSet: ModelData_TextureSet): this;
    /**
     * Returns `true` if no textures in texture set.
     */
    isEmpty(): boolean;
    /**
     * Equality operator.
     * Returns `true` if all textures of two sets are equal.
     */
    isEqual(theTextureSet: ModelData_TextureSet | null | undefined): boolean;
    /**
     * Removes form texture set if exist.
     * Returns `true` if deleting was successfully.
     */
    remove(theTexture: ModelData_Texture): boolean;
    /**
     * Returns iterable to added components.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const texture of textureSet.textures()) {
     *   // Access to the texture
     * }
     * ```
     * 
     * This method performs the same function as the C++ {@link https://docs.cadexchanger.com/sdk/classcadex_1_1_model_data___texture_set_1_1_texture_iterator.html ModelData_TextureSet::TextureIterator} class.
     */
    textures(): Iterable<ModelData_Texture>;
}

/**
 * Defines types of texture.
 */
export enum ModelData_TextureType {
    ModelData_TT_Unknown = 0,
    ModelData_TT_DiffuseMap = 1,
    ModelData_TT_SpecularMap = 2,
    ModelData_TT_EmissiveMap = 3,
    ModelData_TT_BumpMap = 4,
    ModelData_TT_NormalMap = 5,
    ModelData_TT_DisplacementMap = 6,
    ModelData_TT_SphereEnvironmentMap = 7,
}

/**
 * Defines a visitor of the textures.
 */
export abstract class ModelData_TextureVisitor {
    abstract visitFileTexture(theFileTexture: ModelData_FileTexture): Promise<void> | void;
    abstract visitPixMapTexture(thePixMapTexture: ModelData_PixMapTexture): Promise<void> | void;
}

/**
 * Texture wrapping mode.
 */
export enum ModelData_TextureWrapMode {
    ModelData_TWM_ClampToEdge = 0,
    ModelData_TWM_Repeat = 1,
    ModelData_TWM_MirroredRepeat = 2,
}

/**
 * Defines a transformation matrix.
 */
export class ModelData_Transformation {
    /**
     * Creates an instance of ModelData_Transformation.
     */
    constructor(theMatrix?: Array<number>);
    /**
     * Elements of transformation 4x4 matrix.
     */
    get elements(): ReadonlyArray<number>;
    /**
     * Returns `true` if the matrix is identity.
     */
    get isIdentity(): boolean;
    /**
     * Scale factor. Default is `1`.
     */
    get scaleFactor(): number;
    set scaleFactor(theScaleFactor: number);
    /**
     * Creates copy of the current object.
     */
    clone(): ModelData_Transformation;
    /**
     * Copies values from another transformation.
     */
    copy(theTrsf: ModelData_Transformation): this;
    /**
     * Retrieves individual matrix elements.
     */
    data(theRow: number, theCol: number): number;
    /**
     * Compares if two transformation are equal within a tolerance.
     */
    isEqual(theTrsf: ModelData_Transformation): boolean;
    /**
     * Resets this transformation to be identity.
     */
    makeIdentity(): this;
    /**
     * Multiplies this matrix with another one.
     */
    multiply(theTrsf: ModelData_Transformation): this;
    /**
     * Sets rotation part of transformation.
     */
    setRotationPart(theV00: number, theV01: number, theV02: number, theV10: number, theV11: number, theV12: number, theV20: number, theV21: number, theV22: number): this;
    /**
     * Sets translation part of transformation.
     */
    setTranslationPart(theX: number, theY: number, theZ: number): this;
    /**
     * Returns JSON representation of the transformation.
     */
    toJSON(): Array<number>;
    /**
     * Returns string representation of the transformation.
     */
    toString(): string;
}

/**
 * Defines a 3D vector.
 */
export class ModelData_Vector {
    constructor(x?: number, y?: number, z?: number);
    /**
     * A tolerance to compare if two vectors are collinear.
     */
    static get angularTolerance(): number;
    /**
     * A tolerance to compare coincidence of two vectors.
     */
    static get coincidenceTolerance(): number;
    /**
     * X coord.
     */
    get x(): number;
    set x(x: number);
    /**
     * Y coord.
     */
    get y(): number;
    set y(y: number);
    /**
     * Z coord.
     */
    get z(): number;
    set z(z: number);
    /**
     * Creates vector from object implementing {@link ModelData_XY} interface.
     */
    static fromXYZ(theXYZ: ModelData_XYZ): ModelData_Vector;
    add(theOther: ModelData_XYZ): this;
    addScaled(theOther: ModelData_XYZ, theScale: number): this;
    addVectors(theOther1: ModelData_XYZ, theOther2: ModelData_XYZ): this;
    /**
     * Returns the angle between this vector and the other in radians.
     */
    angle(theOther: ModelData_Vector): number;
    clone(): ModelData_Vector;
    copy(theXYZ: ModelData_XYZ): this;
    cross(theOther: ModelData_XYZ): this;
    crossVectors(a: ModelData_XYZ, b: ModelData_XYZ): this;
    divide(theOther: ModelData_XYZ): this;
    divideScalar(theScalar: number): this;
    dot(theOther: ModelData_XYZ): number;
    /**
     * Compares if two vectors are equal within a distance tolerance.
     */
    isEqual(theXYZ: ModelData_XYZ, theTolerance?: number): boolean;
    /**
     * Compares if two vectors are parallel within a distance tolerance.
     */
    isParallel(theOther: ModelData_Vector, theTolerance: number): boolean;
    /**
     * Returns a modulus.
     */
    modulus(): number;
    multiply(theOther: ModelData_XYZ): this;
    multiplyScalar(theScalar: number): this;
    /**
     * Normalizes the vector.
     */
    normalize(): this;
    /**
     * Returns a vector which is a normalized vector of this.
     */
    normalized(): ModelData_Vector;
    /**
     * Reverses the vector.
     */
    reverse(): this;
    /**
     * Returns a vector which is a reversed vector of this.
     */
    reversed(): ModelData_Vector;
    /**
     * Sets coordinates.
     */
    setCoord(x: number, y: number, z: number): this;
    /**
     * Set modulus of the vector.
     */
    setModulus(theModulus: number): this;
    /**
     * Returns a square modulus.
     */
    squareModulus(): number;
    subtract(theOther: ModelData_XYZ): this;
    subtractVectors(theOther1: ModelData_XYZ, theOther2: ModelData_XYZ): this;
    /**
     * Returns JSON representation of the vector.
     */
    toJSON(): ModelData_XYZ;
    /**
     * Returns string representation of the vector.
     */
    toString(): string;
    /**
     * Transforms the vector with a transformation matrix.
     */
    transform(theTrsf: ModelData_Transformation): this;
    /**
     * Returns a vector which is transformed with a transformation matrix.
     */
    transformed(theTrsf: ModelData_Transformation): ModelData_Vector;
}

/**
 * Defines a 2D vector.
 */
export class ModelData_Vector2d {
    constructor(x?: number, y?: number);
    /**
     * A tolerance to compare if two vectors are collinear.
     */
    static get angularTolerance(): number;
    static get coincidenceTolerance(): number;
    /**
     * X coord.
     */
    get x(): number;
    set x(x: number);
    /**
     * Y coord.
     */
    get y(): number;
    set y(y: number);
    /**
     * Creates vector from object implementing {@link ModelData_XY} interface.
     */
    static fromXY(theXY: ModelData_XY): ModelData_Vector2d;
    add(theOther: ModelData_XY): this;
    addScaled(theOther: ModelData_XY, theScale: number): this;
    addVectors(theOther1: ModelData_XY, theOther2: ModelData_XY): this;
    /**
     * Computes the angle in radians with respect to the positive x-axis.
     */
    angle(): number;
    clone(): ModelData_Vector2d;
    copy(theXY: ModelData_XY): this;
    cross(theOther: ModelData_XY): number;
    divide(theOther: ModelData_XY): this;
    divideScalar(theScalar: number): this;
    dot(theOther: ModelData_XY): number;
    /**
     * Compares if two vectors are equal within a distance tolerance.
     */
    isEqual(theXY: ModelData_XY, theTolerance?: number): boolean;
    /**
     * Compares if two direction are parallel within a distance tolerance.
     */
    isParallel(theOther: ModelData_Vector2d, theTolerance: number): boolean;
    /**
     * Returns a modulus.
     */
    modulus(): number;
    multiply(theOther: ModelData_XY): this;
    multiplyScalar(theScalar: number): this;
    /**
     * Normalizes the vector.
     */
    normalize(): this;
    /**
     * Returns a vector which is a normalized vector of this.
     */
    normalized(): ModelData_Vector2d;
    /**
     * Reverses the vector.
     */
    reverse(): this;
    /**
     * Returns a vector which is a reversed vector of this.
     */
    reversed(): ModelData_Vector2d;
    /**
     * Sets coordinates.
     */
    setCoord(x: number, y: number): this;
    /**
     * Set modulus of the vector.
     */
    setModulus(theModulus: number): this;
    /**
     * Returns a square modulus.
     */
    squareModulus(): number;
    subtract(theOther: ModelData_XY): this;
    subtractVectors(theOther1: ModelData_XY, theOther2: ModelData_XY): this;
    /**
     * Returns JSON representation of the vector.
     */
    toJSON(): ModelData_XY;
    /**
     * Returns string representation of the vector.
     */
    toString(): string;
}

/**
 * Defines topological vertex.
 */
export class ModelData_Vertex extends ModelData_Shape {
    /**
     * Creates an instance of ModelData_Vertex from the point.
     */
    constructor(thePoint: ModelData_Point);
    /**
     * Point assigned to this vertex.
     */
    get point(): ModelData_Point;
}

/**
 * Defines a connected set of edges.
 * 
 * Wire can be used to define a {@link ModelData_Face face} boundary
 * or just a set of {@link ModelData_Edge edges}.
 */
export class ModelData_Wire extends ModelData_Shape {
    /**
     * Creates an instance of ModelData_Wire.
     */
    constructor(theEdge?: ModelData_Edge);
    [Symbol.iterator](): Iterator<ModelData_Edge>;
    /**
     * Adds an edge to the wire.
     */
    append(theEdge: ModelData_Edge): boolean;
}

/**
 * 2D Point interface.
 */
export interface ModelData_XY {
    x: number;
    y: number;
}

/**
 * 3D Point interface.
 */
export interface ModelData_XYZ {
    x: number;
    y: number;
    z: number;
}

/**
 * The light which globally illuminates all objects in the scene equally.
 */
export class ModelPrs_AmbientLight extends ModelPrs_Light {
    /**
     * Creates an instance of ModelPrs_AmbientLight.
     */
    constructor(theColor?: ModelData_ColorObject, theIntensity?: number);
}

/**
 * Stores result of the angular measurement.
 */
export abstract class ModelPrs_AngularMeasurement extends ModelPrs_Measurement {
    /**
     * Angle unit.
     */
    get angleUnit(): Base_AngleUnit;
    set angleUnit(theAngleUnit: Base_AngleUnit);
    toString(): string;
}

/**
 * {@link ModelPrs_Annotation} configuration interface.
 */
export interface ModelPrs_AnnotationConfig {
    /**
     * DOM element to render the label.
     */
    labelElement: HTMLElement | undefined;
    /**
     * Initial value for {@link ModelPrs_Annotation#labelShown} property
     */
    labelShown: boolean | undefined;
    /**
     * DOM element to render the marker.
     */
    markerElement: HTMLElement;
    /**
     * Initial value for {@link ModelPrs_Annotation#markerShown} property
     */
    markerShown: boolean | undefined;
    /**
     * World-space position of the annotation.
     */
    position: ModelData_Point;
    /**
     * Optional view3d object associated with the Annotation.
     */
    sceneNode: ModelPrs_SceneNode | undefined;
}

/**
 * A {@link ModelPrs_Marker} with an HTML marker and label attached to it.
 */
export class ModelPrs_Annotation extends ModelPrs_Marker {
    constructor(theConfig: ModelPrs_AnnotationConfig);
    /**
     * Indicates whether the label element is shown or not.
     */
    get isLabelShown(): boolean;
    set isLabelShown(theShown: boolean);
    /**
     * Indicates whether the marker element is shown or not.
     */
    get isMarkerShown(): boolean;
    set isMarkerShown(theShown: boolean);
    /**
     * Optional label element associated with Annotation.
     */
    get labelElement(): HTMLElement | undefined;
    /**
     * Marker element associated with Annotation.
     */
    get markerElement(): HTMLElement;
    /**
     * Scene object associated with the Annotation.
     */
    get sceneNode(): ModelPrs_SceneNode | undefined;
}


export type ModelPrs_CameraChangedEvent<CameraType extends ModelPrs_Camera = ModelPrs_Camera> = ModelPrs_Event<"changed",CameraType> & {
}


export type ModelPrs_CameraEventMap<CameraType extends ModelPrs_Camera> = {
    changed: ModelPrs_CameraChangedEvent<CameraType>;
}

/**
 * Defines a camera paddings in units of the camera's normalized device coordinate (NDC) space (should be in range [0, 1]).
 */
export type ModelPrs_CameraPaddings = {
    left?: number;
    right?: number;
    top?: number;
    bottom?: number;
}


export class ModelPrs_Camera extends ModelPrs_EventDispatcher {
    /**
     * Initializes camera with the default properties.
     */
    constructor();
    /**
     * The far Z-clipping plane position.
     */
    get far(): number;
    /**
     * Camera frustum vertical field of view, from bottom to top of view, in degrees. Default is 45.
     * Relevant for {@link ModelPrs_CameraProjectionType Perspective} projection type only.
     */
    get fov(): number;
    set fov(theFov: number);
    /**
     * The near Z-clipping plane position.
     */
    get near(): number;
    /**
     * Position of the camera. Default is (0, 0, 0).
     */
    get position(): ModelData_Point;
    /**
     * To preserve correct orthographic/perspective projection type switching on set the `scale` is automatically recalculated.
     */
    set position(thePosition: ModelData_Point);
    /**
     * Camera projection type. Default is {@link ModelPrs_CameraProjectionType Isometric}
     */
    get projectionType(): ModelPrs_CameraProjectionType;
    set projectionType(theType: ModelPrs_CameraProjectionType);
    /**
     * Camera scale.
     * For orthographic projection the scale factor corresponds to parallel scale of view mapping.
     * For perspective camera scale factor relates to distance between position and target.
     */
    get scale(): number;
    /**
     * Target of the camera. Default is (0, 1, 0).
     */
    get target(): ModelData_Point;
    set target(theTarget: ModelData_Point);
    /**
     * Up vector of the camera. Default is (0, 0, 1).
     */
    get up(): ModelData_Direction;
    set up(theUp: ModelData_Direction);
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_CameraEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_CameraEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Fit camera to see whole box.
     */
    fitBox(theBox: ModelData_Box, thePaddings?: ModelPrs_CameraPaddings): void;
    /**
     * Calculates camera look direction.
     */
    getDirection(theTarget?: ModelData_Direction): ModelData_Direction;
    /**
     * Calculate frustum planes for the camera projection volume.
     * Frustum is a convex volume determined by six planes directing inwards.
     */
    getFrustum(): Object;
    /**
     * Changes position to `thePoint` and updates camera target
     * to preserve direction and distance between position and target.
     */
    moveTo(thePoint: ModelData_XYZ): void;
    /**
     * Calculates orthogonalized up direction vector.
     */
    orthogonalizedUp(): ModelData_Direction;
    /**
     * Orthogonalize up direction vector.
     */
    orthogonalizeUp(): void;
    /**
     * Translates the center of the view along `x` and `y` axes of camera space
     * preserving camera direction and distance between `position` and `target`.
     */
    pan(dx: number, dy: number): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_Camera#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_CameraEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_CameraEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Rotates the center of the view about the coordinate system of reference of the screen
     * for which the origin is gravity point, with a relative angular value in radians.
     */
    rotate(ax: number, ay: number, az: number, theGravity: ModelData_XYZ): void;
    /**
     * Sets position, target and up direction of the camera.
     * To preserve correct orthographic/perspective projection type switching the camera `scale` is automatically recalculated.
     */
    set(thePosition: ModelData_Point, theTarget: ModelData_Point, theUp: ModelData_Direction, theNear?: number, theFar?: number): void;
    /**
     * Changes the near and far Z-clipping plane positions.
     * For orthographic projection, theNear, theFar can be negative or positive.
     * For perspective projection, only positive values are allowed.
     * 
     * Exception is raised if non-positive values are specified for perspective projection
     * or `theNear` >= `theFar`.
     */
    setZRange(theNear: number, theFar: number): void;
    /**
     * Translates the point from the camera's normalized device coordinate (NDC) space into world space.
     */
    translatePointFromNDCSpaceToWorldSpace(thePoint: ModelData_Point, theTarget?: ModelData_Point): ModelData_Point;
    /**
     * Translates the point from world space into the camera's normalized device coordinate (NDC) space.
     */
    translatePointFromWorldSpaceToNDCSpace(thePoint: ModelData_Point, theTarget?: ModelData_Point): ModelData_Point;
    /**
     * Estimate Z-min and Z-max planes of projection volume to match the displayed objects bounding box.
     * For orthogonal projection the view volume contains the bounding box completely.
     * For perspective projection the view volume is adjusted such that it contains the bounding box part, located in front of the camera.
     */
    zFitAll(theBox: ModelData_Box): void;
    /**
     * Scales the camera according to a zoom factor about the coordinate system of reference of the screen
     * for which the origin is gravity point.
     * If the gravity point is omitted, the camera position is used (which corresponds to the zooming about center of the screen).
     */
    zoom(theFactor: number, theGravity?: ModelData_XYZ): void;
}


export class ModelPrs_CameraManipulationHandler extends ModelPrs_InputHandler {
    /**
     * Creates an instance of ModelPrs_CameraManipulationHandler.
     */
    constructor(theViewPort: ModelPrs_ViewPort);
    /**
     * Gravity point which the camera rotates around.
     */
    get gravityPoint(): ModelData_Point;
    set gravityPoint(theGravityPoint: ModelData_Point);
    multiTouchHandler: ModelPrs_MultiPointInputHandler;
    panHandler: ModelPrs_SinglePointInputHandler;
    rotateHandler: ModelPrs_SinglePointInputHandler;
    get viewport(): ModelPrs_ViewPort;
    zoomHandler: ModelPrs_SinglePointInputHandler;
}


export class ModelPrs_CameraMultiTouchHandler extends ModelPrs_PinchInputHandler {
    /**
     * Creates an instance of ModelPrs_CameraMultiTouchHandler.
     */
    constructor(theViewPort: ModelPrs_ViewPort);
    /**
     * Default value is `1`.
     */
    panSpeed: number;
    get viewport(): ModelPrs_ViewPort;
    /**
     * Default value is `1`.
     */
    zAxisRotationSpeed: number;
    /**
     * Default value is `1`.
     */
    zoomSpeed: number;
}


export class ModelPrs_CameraPanHandler extends ModelPrs_SinglePointInputHandler {
    /**
     * Creates an instance of ModelPrs_CameraPanHandler.
     */
    constructor(theViewPort: ModelPrs_ViewPort);
    /**
     * Default value is `1`.
     */
    panSpeed: number;
    get viewport(): ModelPrs_ViewPort;
}

/**
 * ViewPort camera projection mode.
 */
export enum ModelPrs_CameraProjectionType {
    Isometric = 0,
    Perspective = 1,
}


export class ModelPrs_CameraRotateHandler extends ModelPrs_SinglePointInputHandler {
    /**
     * Creates an instance of ModelPrs_CameraRotateHandler.
     */
    constructor(theViewPort: ModelPrs_ViewPort, theGravityPoint?: ModelData_Point);
    /**
     * The target the camera rotates around.
     */
    gravityPoint: ModelData_Point;
    /**
     * Default value is `1.5`.
     */
    rotateSpeed: number;
    get viewport(): ModelPrs_ViewPort;
}

/**
 * Defines the type of the gravity point using by {@link ModelPrs_CameraZoomHandler}.
 */
export enum ModelPrs_CameraZoomHandlerGravityPoint {
    ScreenCenter = 0,
    PointerPosition = 1,
}


export class ModelPrs_CameraZoomHandler extends ModelPrs_SinglePointInputHandler {
    /**
     * Creates an instance of ModelPrs_CameraZoomHandler.
     */
    constructor(theViewPort: ModelPrs_ViewPort);
    get viewport(): ModelPrs_ViewPort;
    /**
     * Default value is {@link ModelPrs_CameraZoomHandlerGravityPoint.ScreenCenter `ScreenCenter`};
     */
    wheelZoomGravityPoint: ModelPrs_CameraZoomHandlerGravityPoint;
    /**
     * Default value is `false`;
     */
    wheelZoomReverseDirection: boolean;
    /**
     * Default value is `1`.
     */
    zoomSpeed: number;
}


export type ModelPrs_ClipPlaneEventMap<ClipPlaneType extends ModelPrs_ClipPlane> = ModelPrs_FieldChangedEventMap<ClipPlaneType> & {
    changed: ModelPrs_Event<"changed", ClipPlaneType>;
}

/**
 * Class represents "clipping plane" in 3D space.
 */
export class ModelPrs_ClipPlane extends ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_ClipPlane.
     */
    constructor(thePlane: ModelData_Plane);
    /**
     * Capping appearance.
     */
    get cappingAppearance(): ModelData_Appearance;
    set cappingAppearance(theCappingAppearance: ModelData_Appearance);
    /**
     * Indicates to generate capping plane (if possible) or not. Default is `true`.
     */
    get isCappingEnabled(): boolean;
    set isCappingEnabled(theIsCappingEnabled: boolean);
    /**
     * Indicates to render hatch for capping plane (if possible) or not.
     */
    get isHatchingEnabled(): boolean;
    /**
     * Indicates to render hatch for capping plane (if possible) or not.
     */
    set isHatchingEnabled(theIsHatchingEnabled: boolean);
    /**
     * Indicates to show controls (arrow) or not. Default is `true`.
     */
    get isShowControls(): boolean;
    set isShowControls(theIsShowControls: boolean);
    /**
     * Indicates to show transparent plane or not. Default is `true`.
     */
    get isShowPlane(): boolean;
    set isShowPlane(theIsShowPlane: boolean);
    /**
     * A plane located in 3D space with an axis placement three axis.
     */
    get plane(): ModelData_Plane;
    set plane(thePlane: ModelData_Plane);
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_ClipPlaneEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ClipPlaneEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_ClipPlane#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_ClipPlaneEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ClipPlaneEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}


export type ModelPrs_ClipPlaneInputHandlerClipPlaneMovedEvent<ClipPlaneInputHandlerType extends ModelPrs_ClipPlaneInputHandler = ModelPrs_ClipPlaneInputHandler> = ModelPrs_Event<"clipPlaneMoved",ClipPlaneInputHandlerType> & {
    clipPlane: ModelPrs_ClipPlane;
}


export type ModelPrs_ClipPlaneInputHandlerEventMap<ClipPlaneInputHandlerType extends ModelPrs_ClipPlaneInputHandler = ModelPrs_ClipPlaneInputHandler> = {
    clipPlaneMoved: ModelPrs_ClipPlaneInputHandlerClipPlaneMovedEvent<ClipPlaneInputHandlerType>;
}


export class ModelPrs_ClipPlaneInputHandler extends ModelPrs_SinglePointInputHandler {
    constructor(theViewport: ModelPrs_ViewPort);
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_ClipPlaneInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ClipPlaneInputHandlerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_ClipPlaneInputHandler#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_ClipPlaneInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ClipPlaneInputHandlerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}


export type ModelPrs_ClipPlanesManagerEventMap<ClipPlanesManagerType extends ModelPrs_ClipPlanesManager> = {
    globalClipPlaneAdded: ModelPrs_GlobalClipPlaneAddedEvent<ClipPlanesManagerType>;
    globalClipPlaneRemoved: ModelPrs_GlobalClipPlaneRemovedEvent<ClipPlanesManagerType>;
    globalClipPlanesRemovedAll: ModelPrs_GlobalClipPlanesRemovedAllEvent<ClipPlanesManagerType>;
}

/**
 * Event emitted when the clip plane is added to the clip planes manager.
 */
export type ModelPrs_GlobalClipPlaneAddedEvent<ClipPlanesManagerType extends ModelPrs_ClipPlanesManager = ModelPrs_ClipPlanesManager> = ModelPrs_Event<"globalClipPlaneAdded",ClipPlanesManagerType> & {
    clipPlane: ModelPrs_ClipPlane;
}

/**
 * Event emitted when the clip plane is removed from the clip planes manager.
 */
export type ModelPrs_GlobalClipPlaneRemovedEvent<ClipPlanesManagerType extends ModelPrs_ClipPlanesManager = ModelPrs_ClipPlanesManager> = ModelPrs_Event<"globalClipPlaneRemoved",ClipPlanesManagerType> & {
    clipPlane: ModelPrs_ClipPlane;
}

/**
 * Event emitted when all clip planes are removed from the clip planes manager.
 */
export type ModelPrs_GlobalClipPlanesRemovedAllEvent<ClipPlanesManagerType extends ModelPrs_ClipPlanesManager = ModelPrs_ClipPlanesManager> = ModelPrs_Event<"globalClipPlanesRemovedAll",ClipPlanesManagerType> & {
    clipPlanes: Array<ModelPrs_ClipPlane>;
}

/**
 * Manager of global clip planes for the {@link ModelPrs_ViewPort ViewPort}.
 */
export class ModelPrs_ClipPlanesManager extends ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_ClipPlanesManager.
     */
    constructor();
    /**
     * Number of added global clip planes.
     */
    get numberOfGlobalClipPlanes(): number;
    get viewport(): ModelPrs_ViewPort | null;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_ClipPlanesManagerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ClipPlanesManagerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Adds global clip plane to the manager.
     */
    addGlobalClipPlane(theClipPlane: ModelPrs_ClipPlane): void;
    /**
     * Returns `true` if the manager contains the global clip plane. Otherwise returns `false`.
     */
    containsGlobalClipPlane(theClipPlane: ModelPrs_ClipPlane): boolean;
    /**
     * Returns iterable to stored global clip planes.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const clipPlane of clipPlanesManager.globalClipPlanes()) {
     *   // Access to the clip plane
     * }
     * ```
     */
    globalClipPlanes(): Iterable<ModelPrs_ClipPlane>;
    /**
     * Removes all global clip planes from the manager.
     */
    removeAllGlobalClipPlanes(): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_ClipPlanesManager#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_ClipPlanesManagerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ClipPlanesManagerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes global clip plane from the manager.
     */
    removeGlobalClipPlane(theClipPlane: ModelPrs_ClipPlane): void;
}


export type ModelPrs_ContextMenuHandlerEventMap<ContextMenuHandlerType extends ModelPrs_ContextMenuHandler> = ModelPrs_SinglePointInputHandlerEventMap<ContextMenuHandlerType> & {
    contextMenu: ModelPrs_Event<"contextMenu", ContextMenuHandlerType>;
}

/**
 * Handler that interprets a right click or long touch press as context menu event.
 */
export class ModelPrs_ContextMenuHandler extends ModelPrs_TapInputHandler {
    /**
     * Creates an instance of ModelPrs_SelectionHandler.
     */
    constructor();
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_ContextMenuHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ContextMenuHandlerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Handles context menu event fires when the user attempts to open a context menu.
     * 
     * By default it just dispatches `contextMenu` {@link ModelPrs_PointerInputEvent event}.
     */
    contextMenu(theEvent: ModelPrs_PointerInputEvent): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_ContextMenuHandler#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_ContextMenuHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ContextMenuHandlerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}

/**
 * A light that gets emitted in a specific direction.
 * This light will behave as though it is infinitely far away
 * and the rays produced from it are all parallel.
 * The common use case for this is to simulate daylight.
 */
export class ModelPrs_DirectionalLight extends ModelPrs_Light {
    /**
     * Creates an instance of ModelPrs_DirectionalLight.
     */
    constructor(theDirection: ModelData_Direction, theColor?: ModelData_ColorObject, theIsHeadlight?: boolean);
    /**
     * Direction of the light source.
     */
    get direction(): ModelData_Direction;
    set direction(theDirection: ModelData_Direction);
}

/**
 * Display mode for visualization.
 */
export enum ModelPrs_DisplayMode {
    Wireframe = 0,
    Shaded = 1,
    ShadedWithBoundaries = 2,
    Undefined = 100,
}

/**
 * Event dispatcher listener type.
 */
 export type ModelPrs_EventDispatcherListenerType<EventTypeType extends string, EventDispatcherType extends ModelPrs_EventDispatcher, EventType = ModelPrs_Event<EventTypeType, EventDispatcherType>> = (theEvent: EventType) => any;

/**
 * Base interface for all events.
 */
export interface ModelPrs_Event<TypeType extends string, TargetType extends ModelPrs_EventDispatcher> {
    readonly target: TargetType;
    readonly type: TypeType;
}

/**
 * Implements {@link https://developer.mozilla.org/en-US/docs/Web/API/EventTarget EventTarget} interface.
 * Base class which allow objects receive events and may have listeners for them.
 */
export class ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_EventDispatcher.
     */
    constructor();
    /**
     * Use @ignore to declare method with readable signature is (j|t)sdoc files
     */
    addEventListener<EventDispatcherType extends ModelPrs_EventDispatcher>(theType: string, theListener: ModelPrs_EventDispatcherListenerType<string, EventDispatcherType>): void;
    /**
     * Dispatches an event, invoking the affected event listeners in the appropriate order.
     */
    dispatchEvent(theEvent: {[index: string]: any, type: string}): void;
    /**
     * Use @ignore to declare method with readable signature is (j|t)sdoc files
     */
    removeEventListener<EventDispatcherType extends ModelPrs_EventDispatcher>(theType: string, theListener: ModelPrs_EventDispatcherListenerType<string, EventDispatcherType>): void;
}


export type ModelPrs_ExploderEventMap<ExploderType extends ModelPrs_Exploder> = ModelPrs_FieldChangedEventMap<ExploderType> & {
}

/**
 * Provides the ability to get an 'exploded' model view - when model parts separated by distance.
 * Temporarily changes transformation of displayed objects according to the `value` of explosion.
 */
export class ModelPrs_Exploder extends ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_Exploder.
     */
    constructor();
    /**
     * Indicates whether the exploder is currently active.
     */
    get isActive(): boolean;
    set isActive(theIsActive: boolean);
    /**
     * Explosion value. It may be between 0.0 (unexploded) and 1.0 (fully exploded).
     */
    get value(): number;
    set value(theValue: number);
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_ExploderEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ExploderEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_Exploder#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_ExploderEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ExploderEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}

/**
 * Provides the ability to generate mesh from text.
 */
export class ModelPrs_Font {
    /**
     * Construction from "typeface.js" font has been deprecated. Use {@link ModelPrs_Font.fromTypefaceFont} method instead.
     * @deprecated
     */
    constructor(theFont: Object);
    /**
     * Distance from baseline of highest ascender. In font units, not pixels.
     */
    get ascender(): number;
    /**
     * Distance from baseline of lowest descender. In font units, not pixels.
     */
    get descender(): number;
    /**
     * The font's family name.
     */
    get familyName(): string;
    /**
     * The amount of space that should be included between lines.
     */
    get lineGap(): number;
    /**
     * The font's sub-family name.
     */
    get subfamilyName(): string;
    /**
     * The size of the font's internal coordinate grid.
     */
    get unitsPerEm(): number;
    /**
     * Creates font from {@link https://github.com/foliojs/fontkit fontkit} font instance.
     */
    static fromFontkitFont(theFont: Object): ModelPrs_Font;
    /**
     * Creates font from {@link https://github.com/opentypejs/opentype.js opentype.js} font instance.
     */
    static fromOpentypeFont(theFont: Object): ModelPrs_Font;
    /**
     * Creates font from {@link https://github.com/gero3/facetype.js typeface.js} font.
     */
    static fromTypefaceFont(theFont: Object): ModelPrs_Font;
    /**
     * Generates mesh for text.
     */
    generateMesh(theText: string, theSize: number, theSplitIntoSubGroups: false): ModelData_IndexedTriangleSet;
    /**
     * Generates mesh for text with appearance groups for every symbol. Array of appearances is empty.
     */
    generateMesh(theText: string, theSize: number, theSplitIntoSubGroups: true): ModelData_MultiAppearanceIndexedTriangleSet;
}


export type ModelPrs_GeometryEventMap<GeometryType extends ModelPrs_Geometry> = ModelPrs_FieldChangedEventMap<GeometryType> & {
}


export abstract class ModelPrs_Geometry extends ModelPrs_EventDispatcher {
    /**
     * Geometry state.
     */
    get state(): ModelPrs_GeometryState;
    /**
     * Geometry type.
     */
    get type(): ModelPrs_GeometryType;
    /**
     * Accepts a geometry visitor.
     */
    abstract accept(theVisitor: ModelPrs_GeometryVisitor): void;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_GeometryEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_GeometryEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Calculates bounding box of the geometry with applied transformation.
     */
    boundingBox(theTransformation?: ModelData_Transformation | null, theTarget?: ModelData_Box | null): ModelData_Box;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_Geometry#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_GeometryEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_GeometryEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}

/**
 * Defines geometry state.
 */
export enum ModelPrs_GeometryState {
    NotLoaded = 0,
    Loading = 1,
    Completed = 2,
    Failed = 3,
}

/**
 * Defines geometry type.
 */
export enum ModelPrs_GeometryType {
    Body = 0,
    BRepRepresentation = 1,
    PolyVertexSet = 2,
    PolyRepresentation = 3,
    Measurement = 4,
    PMI = 5,
    Drawing = 6,
    Undefined = 100,
}

/**
 * Defines a visitor of the geometry.
 */
export abstract class ModelPrs_GeometryVisitor {
    abstract visitBody(theBody: ModelData_Body, theRep: ModelData_BRepRepresentation | undefined): void;
    abstract visitBRepRepresentation(theBRep: ModelData_BRepRepresentation): void;
    abstract visitMeasurement(theMeasurement: ModelPrs_Measurement): void;
    abstract visitPMIGraphicalElement(theElement: ModelData_PMIGraphicalElement): void;
    abstract visitPolyRepresentation(theRep: ModelData_PolyRepresentation): void;
    abstract visitPolyVertexSet(thePVS: ModelData_PolyVertexSet): void;
}

/**
 * A handler for highlight on viewport.
 */
export class ModelPrs_HighlightingHandler extends ModelPrs_SinglePointInputHandler {
    /**
     * Creates an instance of ModelPrs_HighlightingHandler.
     */
    constructor(theViewport: ModelPrs_ViewPort);
    get viewport(): ModelPrs_ViewPort;
}

/**
 * Creates an instance of ModelPrs_InputEvent.
 */
export class ModelPrs_InputEvent<TypeType extends string, TargetType extends ModelPrs_InputHandler> implements ModelPrs_Event<TypeType, TargetType> {
    /**
     * Indicates whether the alt key was pressed or not when a given pointer event occurs.
     * 
     * See also {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/altKey MouseEvent.altKey} documentation.
     */
    get altKey(): boolean;
    /**
     * Indicates whether the ctrl key was pressed or not when a given pointer event occurs.
     * 
     * See also {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/ctrlKey MouseEvent.ctrlKey} documentation.
     */
    get ctrlKey(): boolean;
    /**
     * Indicates whether the meta key was pressed or not when a given pointer event occurs.
     * 
     * See also {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/metaKey MouseEvent.metaKey} documentation.
     */
    get metaKey(): boolean;
    /**
     * Indicates which keys were pressed on the keyboard to trigger the event.
     * It stores an OR combination of {@link ModelPrs_KeyboardModifier KeyboardModifier} values.
     */
    get modifiers(): number;
    /**
     * Indicates whether the shift key was pressed or not when a given pointer event occurs.
     * 
     * See also {@link https://developer.mozilla.org/en-US/docs/Web/API/MouseEvent/shiftKey MouseEvent.shiftKey} documentation.
     */
    get shiftKey(): boolean;
    /**
     * The input handler which has dispatched the event.
     */
    readonly target: TargetType;
    /**
     * The time (in milliseconds) at which the event was created.
     * 
     * See also {@link https://developer.mozilla.org/en-US/docs/Web/API/Event/timeStamp Event.timeStamp} for more details.
     */
    get timeStamp(): number;
    /**
     * A string containing the input event's type.
     */
    readonly type: TypeType;
    get viewport(): ModelPrs_ViewPort;
}

/**
 * Base class for input handlers registered in {@link ModelPrs_InputManager}.
 */
export class ModelPrs_InputHandler extends ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_InputHandler.
     */
    constructor();
    /**
     * If a input handler is disabled, it will reject all events.
     */
    enabled: boolean;
    /**
     * Indicates whether hover events are accepted by this handler. Default is `false`.
     */
    get isAcceptHoverEvents(): boolean;
    /**
     * Indicates whether keyboard events are accepted by this handler. Default is `false`.
     */
    get isAcceptKeyEvents(): boolean;
    /**
     * Indicates whether pointer buttons events are accepted by this handler. Default is `false`.
     */
    get isAcceptPointerEvents(): boolean;
    /**
     * Indicates whether mouse wheel events are accepted by this handler. Default is `false`.
     */
    get isAcceptWheelEvents(): boolean;
    /**
     * Handles event fired when a pointing device is moved into a viewport boundaries without pressed any buttons.
     */
    hoverEnter(theEvent: ModelPrs_PointerInputEvent): boolean;
    /**
     * Handles event fired when a pointer device is moved out a viewport boundaries without pressed any buttons.
     */
    hoverLeave(theEvent: ModelPrs_PointerInputEvent): void;
    /**
     * Handles event fired when a pointer device is moved within a viewport boundaries without pressed any buttons.
     */
    hoverMove(theEvent: ModelPrs_PointerInputEvent): boolean;
    /**
     * Handles key down event.
     */
    keyDown(theEvent: ModelPrs_KeyboardInputEvent): boolean;
    /**
     * Handles key up event.
     */
    keyUp(theEvent: ModelPrs_KeyboardInputEvent): void;
    /**
     * Handles event is fired when a pointer is no longer be able to generate events.
     */
    pointerCancel(theEvent: ModelPrs_PointerInputEvent): void;
    /**
     * Handles event fired when a pointer becomes _active_.
     * For mouse, it is fired when the device transitions from no buttons pressed to at least one button pressed.
     * For touch, it is fired when physical contact is made with the digitizer.
     * For pen, it is fired when the stylus makes physical contact with the digitizer.
     */
    pointerDown(theEvent: ModelPrs_PointerInputEvent): boolean;
    /**
     * Handles event is fired when a pointer is no longer _active_.
     */
    pointerUp(theEvent: ModelPrs_PointerInputEvent): void;
    /**
     * Handles event fired when an _active_ pointer changes coordinates.
     */
    pointerUpdate(theEvent: ModelPrs_PointerInputEvent): boolean;
    /**
     * Handles resize event.
     */
    resize(theWidth: number, theHeight: number): void;
    /**
     * Handles wheel event fires when the user rotates a wheel button on a pointing device (typically a mouse).
     */
    wheel(theEvent: ModelPrs_WheelInputEvent): boolean;
}

/**
 * Provides information about a point in a {@link ModelPrs_PointerInputEvent}.
 */
export class ModelPrs_InputHandlerPoint {
    /**
     * Creates an instance of ModelPrs_InputHandlerPoint.
     */
    constructor(x: number, y: number);
    /**
     * A unique identifier of the point.
     */
    get id(): number;
    /**
     * The position of this point from the previous press or move event.
     */
    get lastPosition(): ModelData_Point2d;
    /**
     * The time from the previous {@link ModelPrs_PointerInputEvent} that contained this point.
     */
    get lastTimestamp(): number;
    /**
     * The point coordinates (in pixels).
     */
    get position(): ModelData_Point2d;
    /**
     * The position at which this point was pressed.
     */
    get pressPosition(): ModelData_Point2d;
    /**
     * The most recent time at which this point was pressed.
     */
    get pressTimestamp(): number;
    /**
     * The most recent time at which this point was included in a {@link ModelPrs_PointerInputEvent}.
     */
    get timestamp(): number;
}


export type ModelPrs_InputHandlerAddedEvent<InputManagerType extends ModelPrs_InputManager = ModelPrs_InputManager> = ModelPrs_Event<"inputHandlerAdded",InputManagerType> & {
    inputHandler: ModelPrs_InputHandler;
}


export type ModelPrs_InputHandlerRemovedEvent<InputManagerType extends ModelPrs_InputManager = ModelPrs_InputManager> = ModelPrs_Event<"inputHandlerRemoved",InputManagerType> & {
    inputHandler: ModelPrs_InputHandler;
}


export type ModelPrs_InputHandlerReplacedEvent<InputManagerType extends ModelPrs_InputManager = ModelPrs_InputManager> = ModelPrs_Event<"inputHandlerReplaced",InputManagerType> & {
    previousInputHandler: ModelPrs_InputHandler;
    newInputHandler: ModelPrs_InputHandler;
}


export type ModelPrs_InputHandlersRemovedAllEvent<InputManagerType extends ModelPrs_InputManager = ModelPrs_InputManager> = ModelPrs_Event<"inputHandlersRemovedAll",InputManagerType> & {
    inputHandlers: Array<ModelPrs_InputHandler>;
}


export type ModelPrs_InputManagerEventMap<InputManagerType extends ModelPrs_InputManager> = {
    inputHandlerAdded: ModelPrs_InputHandlerAddedEvent<InputManagerType>;
    inputHandlerReplaced: ModelPrs_InputHandlerReplacedEvent<InputManagerType>;
    inputHandlerRemoved: ModelPrs_InputHandlerRemovedEvent<InputManagerType>;
    inputHandlersRemovedAll: ModelPrs_InputHandlersRemovedAllEvent<InputManagerType>;
}

/**
 * Manager of user input handlers of the {@link ModelPrs_ViewPort ViewPort}.
 */
export class ModelPrs_InputManager extends ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_InputManager.
     */
    constructor();
    /**
     * Indicates enabled hover events handling or not. Default is `false` due performance reason.
     */
    get isHoverEnabled(): boolean;
    set isHoverEnabled(theIsHoverEnabled: boolean);
    /**
     * Number of added input handlers.
     */
    get numberOfInputHandlers(): number;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_InputManagerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_InputManagerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Returns `true` if the manager contains the input handler. Otherwise returns `false`.
     */
    containsInputHandler(theInputHandler: ModelPrs_InputHandler): boolean;
    /**
     * Returns iterable to stored input handles.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const inputHandler of inputManager.inputHandlers()) {
     *   // Access to the input handler
     * }
     * ```
     */
    inputHandlers(): Iterable<ModelPrs_InputHandler>;
    /**
     * Removes an input handler from the top of the stack.
     */
    popInputHandler(): ModelPrs_InputHandler | undefined;
    /**
     * Adds an input handler on the stack if it's not already on the stack.
     * Returns `true` if the input handler is successfully added to top of the stack.
     */
    pushInputHandler(theInputHandler: ModelPrs_InputHandler): boolean;
    /**
     * Removes all input handlers from the manager.
     */
    removeAllInputHandlers(): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_InputManager#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_InputManagerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_InputManagerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes specific input handler from the stack.
     * Returns `true` if the input handler has been successfully removed.
     */
    removeInputHandler(theInputHandler: ModelPrs_InputHandler): boolean;
    /**
     * Replace the input handler with another one.
     * Returns `true` if the input handler has been successfully replaced.
     */
    replaceInputHandler(thePreviousInputHandler: ModelPrs_InputHandler, theNewInputHandler: ModelPrs_InputHandler): boolean;
}


export class ModelPrs_KeyboardInputEvent<TypeType extends string = string, TargetType extends ModelPrs_InputHandler = ModelPrs_InputHandler> extends ModelPrs_InputEvent<TypeType,TargetType> {
    /**
     * A physical key on the keyboard (as opposed to the character generated by pressing the key).
     * 
     * See {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/code KeyboardEvent.code} documentation for more details.
     */
    get code(): string;
    /**
     * The value of the key pressed by the user,
     * taking into consideration the state of modifier keys such as "Shift" as well as the keyboard locale and layout.
     * 
     * See {@link https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key KeyboardEvent.key} documentation for more details.
     */
    get key(): string;
    /**
     * Creates keyboard input event from system keyboard event.
     */
    static fromKeyboardEvent(theEvent: KeyboardEvent, theViewport: ModelPrs_ViewPort): ModelPrs_KeyboardInputEvent;
}

/**
 * This enum describes the modifier keys.
 * 
 * > __Notes__:
 * * On Macintosh keyboards, the `Alt` key is also known as the "option" key,
 *   the `Ctrl` key is the "control" key, the `Meta` key is the "command" key (``).
 * * On Windows keyboards, the `Meta` key is the "Windows" key (``).
 */
export enum ModelPrs_KeyboardModifier {
    /**
     * No modifier key is pressed.
     */
    NoModifier = 0,
    /**
     * A Shift key on the keyboard is pressed.
     */
    ShiftModifier = 2,
    /**
     * A Ctrl key on the keyboard is pressed.
     */
    CtrlModifier = 4,
    /**
     * An Alt key on the keyboard is pressed.
     */
    AltModifier = 8,
    /**
     * A Meta key on the keyboard is pressed.
     */
    MetaModifier = 16,
}


export type ModelPrs_LightEventMap<LightType extends ModelPrs_Light> = ModelPrs_FieldChangedEventMap<LightType> & {
    changed: ModelPrs_Event<"changed", LightType>;
}

/**
 * Base class for light sources.
 */
export class ModelPrs_Light extends ModelPrs_EventDispatcher {
    /**
     * The color of the light source. Default is white.
     */
    get color(): ModelData_ColorObject;
    set color(theColor: ModelData_ColorObject);
    /**
     * Numeric value of the light's strength/intensity. Default is `1`.
     */
    get intensity(): number;
    set intensity(theIntensity: number);
    /**
     * Indicates the light position and direction are defined relative to the camera orientation or not.
     */
    get isHeadlight(): boolean;
    set isHeadlight(theIsHeadlight: boolean);
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_LightEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_LightEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_Light#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_LightEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_LightEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}

/**
 * Event emitted when the light source is added to the lights manager.
 */
export type ModelPrs_LightAddedEvent<LightsManagerType extends ModelPrs_LightsManager = ModelPrs_LightsManager> = ModelPrs_Event<"lightAdded",LightsManagerType> & {
    light: ModelPrs_Light;
}

/**
 * Event emitted when the light removed from the lights manager.
 */
export type ModelPrs_LightRemovedEvent<LightsManagerType extends ModelPrs_LightsManager = ModelPrs_LightsManager> = ModelPrs_Event<"lightRemoved",LightsManagerType> & {
    light: ModelPrs_Light;
}


export type ModelPrs_LightsManagerEventMap<LightsManagerType extends ModelPrs_LightsManager> = {
    lightAdded: ModelPrs_LightAddedEvent<LightsManagerType>;
    lightRemoved: ModelPrs_LightRemovedEvent<LightsManagerType>;
    lightsRemovedAll: ModelPrs_LightsRemovedAllEvent<LightsManagerType>;
}

/**
 * Event emitted when all lights removed from the lights manager.
 */
export type ModelPrs_LightsRemovedAllEvent<LightsManagerType extends ModelPrs_LightsManager = ModelPrs_LightsManager> = ModelPrs_Event<"lightsRemovedAll",LightsManagerType> & {
    lights: Array<ModelPrs_Light>;
}

/**
 * Manager of light sources of the {@link ModelPrs_ViewPort ViewPort}.
 */
export class ModelPrs_LightsManager extends ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_LightsManager.
     */
    constructor();
    /**
     * Number of added lights.
     */
    get numberOfLights(): number;
    get viewport(): ModelPrs_ViewPort | null;
    /**
     * Adds default lights to the manager.
     */
    addDefaultLights(): void;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_LightsManagerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_LightsManagerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Adds the light to the manager.
     */
    addLight(theLight: ModelPrs_Light): void;
    /**
     * Returns `true` if the manager contains the light. Otherwise returns `false`.
     */
    containsLight(theLight: ModelPrs_Light): boolean;
    /**
     * Returns iterable to stored lights.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const light of lightManager.lights()) {
     *   // Access to the light
     * }
     * ```
     */
    lights(): Iterable<ModelPrs_Light>;
    /**
     * Removes all lights from the manager.
     */
    removeAllLights(): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_LightsManager#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_LightsManagerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_LightsManagerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes the light from the manager.
     */
    removeLight(theLight: ModelPrs_Light): void;
}

/**
 * Type of light source.
 */
export enum ModelPrs_LightType {
    Ambient = 0,
    Directional = 1,
    Positional = 2,
    Spot = 3,
    Undefined = 100,
}

/**
 * Stores result of the linear measurement.
 */
export abstract class ModelPrs_LinearMeasurement extends ModelPrs_Measurement {
    /**
     * Direction of extension line. Chosen automatically if the value is `null`. Default is `null`.
     */
    get extensionLineDirection(): ModelData_Direction | null;
    set extensionLineDirection(theExtensionLineDirection: ModelData_Direction | null);
    /**
     * Length unit. Default is {@link Base_LengthUnit.Base_LU_Millimeters}.
     */
    get lengthUnit(): Base_LengthUnit;
    set lengthUnit(theLengthUnit: Base_LengthUnit);
    toString(): string;
}


export type ModelPrs_MarkerEventMap<MarkerType extends ModelPrs_Marker> = ModelPrs_FieldChangedEventMap<MarkerType> & {
    canvasPositionChanged: ModelPrs_Event<"canvasPositionChanged", MarkerType>;
    zOrderChanged: ModelPrs_Event<"zOrderChanged", MarkerType>;
}

/**
 * Class represents "marker" in 3D space, which tracks the world and canvas coordinates.
 */
export class ModelPrs_Marker extends ModelPrs_EventDispatcher {
    /**
     * Marker position in canvas space.
     */
    get canvasPosition(): ModelData_Point2d;
    /**
     * Marker position in 3D space.
     */
    get position(): ModelData_Point;
    set position(thePosition: ModelData_Point);
    /**
     * Z-order of marker. The higher value means the further marker from the camera.
     */
    get zOrder(): number;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_MarkerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_MarkerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_Marker#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_MarkerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_MarkerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Calculates canvas position and zOrder from camera.
     */
    update(theCamera: ModelPrs_Camera): void;
}

/**
 * Event emitted when the clip plane is added to the clip planes manager.
 */
export type ModelPrs_MarkerAddedEvent<MarkersManagerType extends ModelPrs_MarkersManager = ModelPrs_MarkersManager> = ModelPrs_Event<"markerAdded",MarkersManagerType> & {
    marker: ModelPrs_Marker;
}

/**
 * Event emitted when the clip plane is removed from the clip planes manager.
 */
export type ModelPrs_MarkerRemovedEvent<MarkersManagerType extends ModelPrs_MarkersManager = ModelPrs_MarkersManager> = ModelPrs_Event<"markerRemoved",MarkersManagerType> & {
    marker: ModelPrs_Marker;
}


export type ModelPrs_MarkersManagerEventMap<MarkersManagerType extends ModelPrs_MarkersManager> = {
    markerAdded: ModelPrs_MarkerAddedEvent<MarkersManagerType>;
    markerRemoved: ModelPrs_MarkerRemovedEvent<MarkersManagerType>;
    markersRemovedAll: ModelPrs_MarkersRemovedAllEvent<MarkersManagerType>;
}

/**
 * Event emitted when all clip planes are removed from the clip planes manager.
 */
export type ModelPrs_MarkersRemovedAllEvent<MarkersManagerType extends ModelPrs_MarkersManager = ModelPrs_MarkersManager> = ModelPrs_Event<"markersRemovedAll",MarkersManagerType> & {
    markers: Array<ModelPrs_Marker>;
}

/**
 * Manager of markers of the {@link ModelPrs_ViewPort ViewPort}.
 */
export class ModelPrs_MarkersManager extends ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_MarkersManager.
     */
    constructor();
    /**
     * Number of added markers.
     */
    get numberOfMarkers(): number;
    get viewport(): ModelPrs_ViewPort | null;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_MarkersManagerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_MarkersManagerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Adds the marker to the manager.
     */
    addMarker(theMarker: ModelPrs_Marker): void;
    /**
     * Returns `true` if the manager contains the marker. Otherwise returns `false`.
     */
    containsMarker(theMarker: ModelPrs_Marker): boolean;
    /**
     * Returns iterable to added markers.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const marker of markersManager.markers()) {
     *   // Access to the marker
     * }
     * ```
     */
    markers(): Iterable<ModelPrs_Marker>;
    /**
     * Removes all markers from the manager.
     */
    removeAllMarkers(): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_MarkersManager#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_MarkersManagerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_MarkersManagerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes the marker from the manager.
     */
    removeMarker(theMarker: ModelPrs_Marker): void;
}


export type ModelPrs_MeasurementEventMap<MeasurementType extends ModelPrs_Measurement> = ModelPrs_FieldChangedEventMap<MeasurementType> & {
    valueChanged: ModelPrs_Event<"valueChanged", MeasurementType>;
}

/**
 * Stores the source data and result of the measurement.
 * Objects of this class can be created using {@link ModelPrs_MeasurementFactory}.
 * 
 * To display the measurement you need to create scene node from it using {@link ModelPrs_SceneNodeFactory}
 * and add that to the scene.
 * When the measurement settings are changed, it's necessary to call {@link ModelPrs_SceneNode ModelPrs_SceneNode#invalidate()}
 * or re-create a scene node for that measurement.
 */
export abstract class ModelPrs_Measurement extends ModelPrs_EventDispatcher {
    /**
     * Length of extension line in millimeters. Default is `40`.
     */
    get extensionLineLength(): number;
    set extensionLineLength(theExtensionLineSize: number);
    /**
     * Length of extension overhang in millimeters. Default is `4`.
     */
    get extensionOverhangLength(): number;
    set extensionOverhangLength(theExtensionOverhangLength: number);
    /**
     * Font size in millimeters.
     */
    get fontSize(): number;
    set fontSize(theFontSize: number);
    /**
     * Number of digits after the decimal point for value. Default is `2`.
     */
    get precision(): number;
    set precision(thePrecision: number);
    /**
     * Measurement type.
     */
    get type(): ModelPrs_MeasurementType;
    /**
     * Measurement result in current units.
     */
    get value(): number;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_MeasurementEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_MeasurementEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_Measurement#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_MeasurementEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_MeasurementEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    toString(): string;
}

/**
 * Creates measurement objects that store the sources and result of a measurement.
 */
export class ModelPrs_MeasurementFactory {
    /**
     * Creates an angle measurement between three points.
     */
    createAngleFromPoints(thePoint1: ModelData_Point, thePoint2: ModelData_Point, thePoint3: ModelData_Point): ModelPrs_AngularMeasurement | null;
    /**
     * Creates a distance measurement between any two points.
     */
    createDistanceFromPoints(thePoint1: ModelData_Point, thePoint2: ModelData_Point): ModelPrs_LinearMeasurement | null;
}

/**
 * Defines a type of measurement.
 */
export enum ModelPrs_MeasurementType {
    Distance = 0,
    AngleBetweenVertexes = 4,
    Undefined = 100,
}


export type ModelPrs_MultiPointInputHandlerEventMap<MultiPointInputHandlerType extends ModelPrs_MultiPointInputHandler> = ModelPrs_PointerInputHandlerEventMap<MultiPointInputHandlerType> & {
    isActiveChanged: ModelPrs_Event<"isActiveChanged", MultiPointInputHandlerType>;
    currentPointsChanged: ModelPrs_Event<"currentPointsChanged", MultiPointInputHandlerType>;
    centroidChanged: ModelPrs_Event<"centroidChanged", MultiPointInputHandlerType>;
}

/**
 * An intermediate class for the handlers which expect a specific number of multiple points.
 */
export class ModelPrs_MultiPointInputHandler extends ModelPrs_PointerInputHandler {
    /**
     * Creates an instance of ModelPrs_MultiPointInputHandler.
     */
    constructor();
    /**
     * A point exactly in the middle of the currently-pressed points.
     * `null` if the handler is not active.
     */
    get centroid(): ModelData_Point2d | null;
    /**
     * Indicates whenever it has taken sole responsibility for handing one or more input points.
     */
    get isActive(): boolean;
    /**
     * The maximum number of points this handler can utilize. Default is 2.
     */
    maximumPointCount: number;
    /**
     * The minimum number of points required to activate this handler. Default is 2.
     */
    minimumPointCount: number;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_MultiPointInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_MultiPointInputHandlerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Returns iterable to stored current points.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const point of inputHandler.currentPoints()) {
     *   // Access to the point
     * }
     * ```
     */
    currentPoints(): Iterable<ModelPrs_InputHandlerPoint>;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_MultiPointInputHandler#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_MultiPointInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_MultiPointInputHandlerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}

/**
 * Encapsulates a picked clip plane.
 */
export class ModelPrs_PickedClipPlaneEntity extends ModelPrs_PickedEntity {
    /**
     * Creates an instance of ModelPrs_PickedClipPlaneEntity.
     */
    constructor(thePoint: ModelData_Point, theTolerance: number, theCliPlane: ModelPrs_ClipPlane);
    /**
     * The picked clip plane.
     */
    clipPlane: ModelPrs_ClipPlane;
    /**
     * Accepts an entity visitor.
     */
    accept(theVisitor: ModelPrs_PickedEntityVisitor): void;
}

/**
 * Encapsulates a picked item.
 */
export abstract class ModelPrs_PickedEntity {
    /**
     * World space point of the intersection.
     */
    point: ModelData_Point;
    /**
     * Tolerance in millimeters used on current entity detection.
     */
    tolerance: number;
    /**
     * Accepts an entity visitor.
     */
    abstract accept(theVisitor: ModelPrs_PickedEntityVisitor): void;
}

/**
 * Defines a visitor of the picked items.
 */
export abstract class ModelPrs_PickedEntityVisitor {
    abstract visitPickedClipPlaneEntity(theEntity: ModelPrs_PickedClipPlaneEntity): void;
    abstract visitPickedNodeEntity(theEntity: ModelPrs_PickedNodeEntity): void;
    abstract visitPickedPolyShapeEntity(theEntity: ModelPrs_PickedPolyShapeEntity): void;
    abstract visitPickedPolyVertexEntity(theEntity: ModelPrs_PickedPolyVertexEntity): void;
    abstract visitPickedShapeEntity(theEntity: ModelPrs_PickedShapeEntity): void;
}

/**
 * Encapsulates a picked node.
 */
export class ModelPrs_PickedNodeEntity extends ModelPrs_PickedEntity {
    /**
     * The picked node.
     */
    node: ModelPrs_SceneNode;
    /**
     * World space normal at the point of intersection.
     */
    get normal(): ModelData_Direction | null;
    /**
     * Accepts an entity visitor.
     */
    accept(theVisitor: ModelPrs_PickedEntityVisitor): void;
}

/**
 * Encapsulates a picked Poly shape.
 */
export class ModelPrs_PickedPolyShapeEntity extends ModelPrs_PickedEntity {
    /**
     * Index of the intersected element inside poly shape:
     * * index of face if the polyShape is {@link ModelData_IndexedTriangleSet}
     * * index of line segment if the polyShape is {@link ModelData_PolyLineSet}
     * * index of vertex if the polyShape is {@link ModelData_PolyPointSet}
     */
    elementIndex: number;
    /**
     * The node that contains the picked poly shape.
     */
    node: ModelPrs_SceneNode;
    /**
     * World space normal at the point of intersection.
     * 
     * > __Note__: the value is available for {@link ModelData_IndexedTriangleSet Indexed Triangle Sets} only.
     */
    get normal(): ModelData_Direction | null;
    /**
     * The picked shape.
     */
    polyShape: ModelData_PolyVertexSet;
    /**
     * U,V coordinates at point of intersection.
     * 
     * > __Note__: the value is available for {@link ModelData_IndexedTriangleSet Indexed Triangle Sets} with UV coordinates.
     */
    get uv(): ModelData_Point2d | null;
    /**
     * Accepts an entity visitor.
     */
    accept(theVisitor: ModelPrs_PickedEntityVisitor): void;
}

/**
 * Encapsulates a picked specific vertex of poly shape.
 */
export class ModelPrs_PickedPolyVertexEntity extends ModelPrs_PickedEntity {
    /**
     * The node that contains the picked shaped.
     */
    node: ModelPrs_SceneNode;
    /**
     * The poly shape that contains the picked vertex.
     */
    polyShape: ModelData_PolyVertexSet;
    /**
     * Index of the intersected vertex inside poly shape.
     */
    vertexIndex: number;
    /**
     * Accepts an entity visitor.
     */
    accept(theVisitor: ModelPrs_PickedEntityVisitor): void;
}

/**
 * Encapsulates a picked B-Rep shape.
 */
export class ModelPrs_PickedShapeEntity extends ModelPrs_PickedEntity {
    /**
     * The node that contains the picked shape.
     */
    node: ModelPrs_SceneNode;
    /**
     * World space normal at the point of intersection.
     */
    get normal(): ModelData_Direction | null;
    /**
     * The picked shape.
     */
    shape: ModelData_Shape;
    /**
     * Accepts an entity visitor.
     */
    accept(theVisitor: ModelPrs_PickedEntityVisitor): void;
}

/**
 * Encapsulates a result of pick operation.
 */
export class ModelPrs_PickResult {
    /**
     * Distance between the origin of the ray and the intersection.
     */
    get distance(): number;
    /**
     * The node which has been intersected on pick operation.
     */
    get node(): ModelPrs_SceneNode | null;
    /**
     * World space normal at the point of intersection.
     */
    get normal(): ModelData_Direction | null;
    /**
     * Picked entity detected on intersecting.
     */
    pickedEntity: ModelPrs_PickedEntity;
    /**
     * World space point of the intersection.
     */
    get point(): ModelData_Point;
}


export type ModelPrs_PinchInputHandlerEventMap<PinchInputHandlerType extends ModelPrs_PinchInputHandler> = ModelPrs_MultiPointInputHandlerEventMap<PinchInputHandlerType> & {
    updated: ModelPrs_Event<"updated", PinchInputHandlerType>;
}

/**
 * PinchInputHandler "updated" event.
 */
export type ModelPrs_PinchInputHandlerUpdatedEvent = {
    type: "updated";
    target: ModelPrs_PinchInputHandler;
}

/**
 * Handler that interprets a multi-finger gesture to interactively rotate, zoom, and drag.
 */
export class ModelPrs_PinchInputHandler extends ModelPrs_MultiPointInputHandler {
    /**
     * Creates an instance of ModelPrs_PinchInputHandler.
     */
    constructor();
    /**
     * The rotation of the pinch gesture in degrees, with positive values clockwise.
     * It is 0 when the gesture begins.
     */
    get rotation(): number;
    /**
     * The scale factor while the pinch gesture is being performed.
     * It is 1.0 when the gesture begins, increases as the points are spread apart,
     * and decreases as the points are brought together.
     */
    get scale(): number;
    /**
     * The translation of the gesture centroid.
     * It is (0, 0) when the gesture begins.
     */
    get translation(): ModelData_Vector2d;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_PinchInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_PinchInputHandlerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_PinchInputHandler#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_PinchInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_PinchInputHandlerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}

/**
 * Defines pointer buttons.
 */
export enum ModelPrs_PointerButton {
    NoButton = 0,
    LeftButton = 1,
    RightButton = 2,
    MiddleButton = 4,
    Undefined = -1,
}

/**
 * The universal input event produced by a hardware agnostic representation of input devices
 * (such as a mouse, pen or contact point on a touch-enable surface).
 */
export class ModelPrs_PointerInputEvent<TypeType extends string = string, TargetType extends ModelPrs_InputHandler = ModelPrs_InputHandler> extends ModelPrs_InputEvent<TypeType,TargetType> {
    /**
     * Indicates the button was pressed/released on the pointer device to trigger the event.
     * If neither buttons nor touch/pen contact changed since last event returns {@link ModelPrs_PointerButton ModelPrs_PointerButton.NoButton}.
     */
    get button(): ModelPrs_PointerButton;
    /**
     * Indicates which buttons are pressed on the pointer when a event is triggered.
     * It stores an OR combination of {@link ModelPrs_PointerButton} values.
     */
    get buttons(): number;
    /**
     * The pointer position when pointer event is dispatched.
     */
    get point(): ModelPrs_InputHandlerPoint;
    /**
     * The device type (mouse, pen, or touch) that caused a given pointer event.
     */
    get pointerType(): ModelPrs_PointerType;
    /**
     * Creates pointer input event from system event.
     */
    static fromPointerEvent(theEvent: PointerEvent, theViewport: ModelPrs_ViewPort, thePoint?: ModelPrs_InputHandlerPoint): ModelPrs_PointerInputEvent;
}


export type ModelPrs_PointerInputHandlerEventMap<PointerInputHandlerType extends ModelPrs_PointerInputHandler> = ModelPrs_FieldChangedEventMap<PointerInputHandlerType> & {
}

/**
 * An intermediate class for handlers which allow filtering based pressed buttons, keyboard modifiers and pointer type.
 */
export class ModelPrs_PointerInputHandler extends ModelPrs_InputHandler {
    /**
     * Creates an instance of ModelPrs_PointerInputHandler.
     */
    constructor();
    /**
     * The maximum distance in pixels that the user must drag an event point
     * in order to have it treated as a drag gesture.
     * Default is 5 pixels.
     */
    get dragDistance(): number;
    set dragDistance(theDragDistance: number);
    /**
     * Specifies the pointer states required to accept pointer event.
     * If keyboard modifier is not specified, the handler does not care which modifiers are pressed.
     * If pointer type is not specified, the handler does not care which device dispatches the event.
     */
    addAcceptedPointerButton(theButton: ModelPrs_PointerButton, theKeyboardModifiers?: number, thePointerType?: string): void;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_PointerInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_PointerInputHandlerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    clearAcceptedPointerButtons(): void;
    removeAcceptedPointerButton(theButton: ModelPrs_PointerButton, theKeyboardModifiers?: number, thePointerType?: string): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_PointerInputHandler#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_PointerInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, ModelPrs_PointerInputHandler, ModelPrs_PointerInputHandlerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}

/**
 * Defines pointer type.
 */
export enum ModelPrs_PointerType {
    Mouse = "mouse",
    Pen = "pen",
    Touch = "touch",
    Undefined = "",
}


export type ModelPrs_SceneEventMap<SceneType extends ModelPrs_Scene> = {
    boundingBoxChanged: ModelPrs_Event<"boundingBoxChanged", SceneType>;
    updated: ModelPrs_Event<"updated", SceneType>;
}

/**
 * Provides CAD Exchanger visualization graph.
 */
export class ModelPrs_Scene extends ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_Scene3D.
     */
    constructor();
    /**
     * Bounding box of the visible nodes on the scene.
     */
    get boundingBox(): ModelData_Box;
    /**
     * Number of added roots.
     */
    get numberOfRoots(): number;
    /**
     * Scene selection manager.
     */
    selectionManager: ModelPrs_SelectionManager;
    /**
     * Accepts a visitor.
     */
    accept(theVisitor: ModelPrs_SceneNodeVisitor): void;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_SceneEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_SceneEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Adds a root scene node.
     */
    addRoot(theRoot: ModelPrs_SceneNode): boolean;
    /**
     * Removes all root scene nodes.
     */
    clear(): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_Scene#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_SceneEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_SceneEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes a root scene node.
     */
    removeRoot(theRoot: ModelPrs_SceneNode): boolean;
    /**
     * Returns iterable to the root nodes.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const root of scene.roots()) {
     *   // Access to the root
     * }
     * ```
     */
    roots(): Iterable<ModelPrs_SceneNode>;
    /**
     * Applies changes of attached Scene Nodes.
     * 
     * Updating the scene can be time-consuming and therefore should be delayed until changes to the underlying scene nodes data have been applied.
     * 
     * This method is asynchronous. It means that changes will be applied piecemeal.
     * 
     * Any manipulations with scene nodes forbidden while changes are applied.
     * Resolved promise indicates all changes were applied.
     */
    update(theProgressScope?: Base_ProgressScope): Promise<void>;
}

/**
 * Represents a node in the visual scene graph.
 * 
 * Scene nodes constitute hierarchy of the logical objects on the 3D scene.
 * A node has a single parent node and may have zero, one or multiple child nodes.
 * 
 * The scene node is not typed: ModelPrs_SceneNode may not have subclasses.
 * Semantics is determined by the application.
 * 
 * Each node can carry various attributes that define how the object or a sub-tree is displayed.
 * Implementation has been optimized to allocate memory only for those attributes items
 * that have been explicitly created (e.g. transformation matrix or a material).
 * When data items are not explicitly defined then no extra memory footprint is incurred.
 * 
 * Scene nodes may not be shared among parents, sharing of heavy-weight data (e.g. geometry)
 * is provided via shareable data attributes. For instance, two instances of the same part in an assembly
 * will be mapped to two scene nodes referring to the same geometry and distinct transformations.
 */
export class ModelPrs_SceneNode extends ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_SceneNode.
     */
    constructor();
    /**
     * Appearance attribute.
     */
    get appearance(): ModelData_Appearance | null;
    set appearance(theAppearance: ModelData_Appearance | null);
    /**
     * Appearance attribute combined with parents appearances.
     */
    get combinedAppearance(): ModelData_Appearance | null;
    /**
     * Display mode attribute combined with parents display modes.
     */
    get combinedDisplayMode(): ModelPrs_DisplayMode;
    /**
     * Selection mode attribute combined with parents selection modes.
     */
    get combinedSelectionMode(): ModelPrs_SelectionMode;
    /**
     * Style attribute combined with parents styles.
     */
    get combinedStyle(): ModelPrs_Style | null;
    /**
     * Transformation attribute combined with parents transformations.
     */
    get combinedTransformation(): ModelData_Transformation | null;
    /**
     * Visibility mode attribute combined with parents visibility modes.
     */
    get combinedVisibilityMode(): ModelPrs_VisibilityMode;
    /**
     * Display mode attribute.
     */
    get displayMode(): ModelPrs_DisplayMode;
    set displayMode(theDisplayMode: ModelPrs_DisplayMode);
    /**
     * Geometry attribute.
     */
    get geometry(): ModelPrs_Geometry | null;
    set geometry(theGeometry: ModelPrs_Geometry | null);
    /**
     * Parent node.
     */
    get parent(): ModelPrs_SceneNode | null;
    /**
     * The scene which the node is attached to.
     * 
     * > __Note__: the property is calculated on every access, iterating up to the root node.
     */
    get scene(): ModelPrs_Scene | null;
    /**
     * Selection mode attribute.
     */
    get selectionMode(): ModelPrs_SelectionMode;
    set selectionMode(theSelectionMode: ModelPrs_SelectionMode);
    /**
     * Style attribute.
     */
    get style(): ModelPrs_Style | null;
    set style(theStyle: ModelPrs_Style | null);
    /**
     * Transformation attribute.
     */
    get transformation(): ModelData_Transformation | null;
    set transformation(theTransformation: ModelData_Transformation | null);
    /**
     * Visibility mode attribute.
     */
    get visibilityMode(): ModelPrs_VisibilityMode;
    set visibilityMode(theVisibilityMode: ModelPrs_VisibilityMode);
    /**
     * Accepts a visitor.
     */
    accept(theVisitor: ModelPrs_SceneNodeVisitor): void;
    /**
     * Adds child node. Returns `false` if the node already has a parent, otherwise returns `true`.
     */
    addChildNode(theChild: ModelPrs_SceneNode): boolean;
    /**
     * Returns iterable to child nodes.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const childNode of node.childNodes()) {
     *   // Access to the child node
     * }
     * ```
     */
    childNodes(): Iterable<ModelPrs_SceneNode>;
    /**
     * Detaches node from parent.
     * 
     * > __Note__: this method does not remove roots from the scene.
     */
    detach(): ModelPrs_SceneNode | null;
    /**
     * Marks scene nodes sub tree to be forcibly updated on the next scene `update()` call.
     */
    invalidate(): void;
    /**
     * Removes child node. Returns `true` if the node has been successfully removed.
     */
    removeChildNode(theChild: ModelPrs_SceneNode): boolean;
    /**
     * Removes all children nodes.
     */
    removeChildNodes(): void;
}

/**
 * Creates a scene nodes and its children from input data model objects.
 * 
 * The factory supports various input types to create scene nodes from:
 * * Entire ModelData_Model;
 * * Assembly, part or instance;
 * * B-Rep or polygonal representation;
 * * Individual body inside B-Rep representation;
 * * Individual mesh (triangle set, polyline set or point set).
 * 
 * There are two ways to create scene nodes:
 * 1. Use createGraph* API that traverses a model entirely, creates scene nodes and their children.
 *    This prevents you from influencing the creation of the scene nodes. Therefore, it is more suitable for
 *    simply displaying the entire model. For example, to take screenshots.
 * 2. Use createNode* API that creates a single scene node. It gives you the ability to process
 *    each scene node and manually create a scene graph. For example, to create items for tree view and add
 *    a relation to scene nodes.
 */
export class ModelPrs_SceneNodeFactory {
    /**
     * Creates scene graph from whole model. Returns `null` if the model is empty.
     */
    createGraphFromModel(theModel: ModelData_Model, theMaskOrName: ModelData_RepresentationMask | string): Promise<(ModelPrs_SceneNode|null)>;
    /**
     * Creates scene node from B-Rep body and optional B-Rep representation.
     */
    createNodeFromBody(theBody: ModelData_Body, theRepresentation?: ModelData_BRepRepresentation): ModelPrs_SceneNode;
    /**
     * Creates scene node from measurement.
     */
    createNodeFromMeasurement(theMeasurement: ModelPrs_Measurement): ModelPrs_SceneNode;
    /**
     * Creates scene node from PMI graphical element.
     */
    createNodeFromPMIGraphicalElement(thePMIGraphicalElement: ModelData_PMIGraphicalElement): ModelPrs_SceneNode;
    /**
     * Creates scene node from poly vertex set.
     */
    createNodeFromPolyVertexSet(thePolyVertexSet: ModelData_PolyVertexSet): ModelPrs_SceneNode;
    /**
     * Creates scene node from polygonal or B-Rep representation.
     */
    createNodeFromRepresentation(theRepresentation: ModelData_Representation): ModelPrs_SceneNode;
    /**
     * Creates scene node from scene graph element.
     */
    createNodeFromSceneGraphElement(theSceneGraphElement: ModelData_SceneGraphElement): ModelPrs_SceneNode;
}

/**
 * Defines a visitor of the scene node.
 */
export abstract class ModelPrs_SceneNodeVisitor {
    abstract visitEnter(theNode: ModelPrs_SceneNode): boolean;
    abstract visitLeave(theNode: ModelPrs_SceneNode): void;
}

/**
 * Encapsulates a selected entity.
 */
export abstract class ModelPrs_SelectedEntity {
    /**
     * Accepts an entity visitor.
     */
    abstract accept(theVisitor: ModelPrs_SelectedEntityVisitor): void;
    /**
     * Compares two selection entity to be equal by value.
     */
    isEqual(theEntity: ModelPrs_SelectedEntity): boolean;
}

/**
 * Defines a visitor of the selected entities.
 */
export abstract class ModelPrs_SelectedEntityVisitor {
    abstract visitPolyShapeEntity(thePolyShapeEntity: ModelPrs_SelectedPolyShapeEntity): void;
    abstract visitPolyVertexEntity(thePolyVertexEntity: ModelPrs_SelectedPolyVertexEntity): void;
    abstract visitShapeEntity(theShapeEntity: ModelPrs_SelectedShapeEntity): void;
}

/**
 * Encapsulates a selected poly vertex set.
 */
export class ModelPrs_SelectedPolyShapeEntity extends ModelPrs_SelectedEntity {
    /**
     * Creates an instance of ModelPrs_SelectedPolyShapeEntity.
     */
    constructor(thePolyShape: ModelData_PolyVertexSet);
    /**
     * Selected poly vertex set.
     */
    get polyShape(): ModelData_PolyVertexSet;
    /**
     * Accepts an entity visitor.
     */
    accept(theVisitor: ModelPrs_SelectedEntityVisitor): void;
}

/**
 * Encapsulates a selected poly vertex of the {@link ModelData_PolyVertexSet poly shape}.
 */
export class ModelPrs_SelectedPolyVertexEntity extends ModelPrs_SelectedEntity {
    /**
     * Creates an instance of ModelPrs_SelectedPolyShapeEntity.
     */
    constructor(thePolyShape: ModelData_PolyVertexSet, theVertexIndex: number);
    /**
     * Selected poly vertex set.
     */
    get polyShape(): ModelData_PolyVertexSet;
    /**
     * Index of the selected vertex inside poly shape.
     */
    get vertexIndex(): number;
    /**
     * Accepts an entity visitor.
     */
    accept(theVisitor: ModelPrs_SelectedEntityVisitor): void;
}

/**
 * Encapsulates a selected BRep shape.
 */
export class ModelPrs_SelectedShapeEntity extends ModelPrs_SelectedEntity {
    /**
     * Creates an instance of ModelPrs_SelectedShapeEntity.
     */
    constructor(theShape: ModelData_Shape);
    /**
     * Selected B-Rep shape.
     */
    get shape(): ModelData_Shape;
    /**
     * Accepts an entity visitor.
     */
    accept(theVisitor: ModelPrs_SelectedEntityVisitor): void;
}

/**
 * A handler for selection on viewport.
 */
export class ModelPrs_SelectionHandler extends ModelPrs_TapInputHandler {
    /**
     * Creates an instance of ModelPrs_SelectionHandler.
     */
    constructor(theViewport: ModelPrs_ViewPort);
    /**
     * The keyboard modifiers used to determine which kind of selection (multiple or single) should applied.
     * `undefined` value disables multiple selection.
     * Default is {@link ModelPrs_KeyboardModifier ModelPrs_KeyboardModifier.CtrlModifier}.
     */
    get multipleSelectionModifier(): number | undefined;
    set multipleSelectionModifier(theMultipleSelectionModifier: number | undefined);
    /**
     * Primary pointer button. Default is {@link ModelPrs_SelectionHandler ModelPrs_PointerButton.LeftButton}
     */
    get primaryButton(): ModelPrs_PointerButton;
    set primaryButton(thePrimaryButton: ModelPrs_PointerButton);
    get viewport(): ModelPrs_ViewPort;
    /**
     * Picks the objects on the scene at the pixel coordinates of the event.
     */
    pick(theEvent: ModelPrs_PointerInputEvent): ModelPrs_PickResult | null;
}


export type ModelPrs_HighlightingItem = ModelPrs_SelectionItem;

/**
 * Encapsulates a selection of specific node or part of node.
 */
export class ModelPrs_SelectionItem {
    /**
     * Creates an instance of ModelPrs_SelectionItem.
     */
    constructor(theNode: ModelPrs_SceneNode, theEntities?: ModelPrs_SelectedEntity | Array<ModelPrs_SelectedEntity> | undefined);
    /**
     * Indicates whether the item represents whole selected node or not.
     */
    get isWholeSelectedNode(): boolean;
    /**
     * The node associated with this selection item.
     */
    get node(): ModelPrs_SceneNode;
    /**
     * Number of selected entities associated with current selection item.
     * `0` if the whole node is selected.
     */
    get numberOfEntities(): number;
    /**
     * Creates SelectionItem from PickResult object.
     */
    static fromPickResult(thePickResult: ModelPrs_PickResult): ModelPrs_SelectionItem | null;
    /**
     * Returns iterable to associated entities.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const entity of item.entities()) {
     *   // Access to the entity
     * }
     * ```
     */
    entities(): Iterable<ModelPrs_SelectedEntity>;
}

/**
 * The event dispatched on highlighting changing
 */
export type ModelPrs_HighlightingChangedEvent<SelectionManagerType extends ModelPrs_SelectionManager = ModelPrs_SelectionManager> = ModelPrs_Event<"highlightingChanged",SelectionManagerType> & {
    added: Array<ModelPrs_HighlightingItem>;
    removed: Array<ModelPrs_HighlightingItem>;
}

/**
 * The event dispatched on selection changing.
 */
export type ModelPrs_SelectionChangedEvent<SelectionManagerType extends ModelPrs_SelectionManager = ModelPrs_SelectionManager> = ModelPrs_Event<"selectionChanged",SelectionManagerType> & {
    added: Array<ModelPrs_SelectionItem>;
    removed: Array<ModelPrs_SelectionItem>;
}


export type ModelPrs_SelectionManagerEventMap<SelectionManagerType extends ModelPrs_SelectionManager> = {
    selectionChanged: ModelPrs_SelectionChangedEvent<SelectionManagerType>;
    highlightingChanged: ModelPrs_HighlightingChangedEvent<SelectionManagerType>;
}

/**
 * Manager of selected items on the {@link ModelPrs_Scene Scene}.
 */
export class ModelPrs_SelectionManager extends ModelPrs_EventDispatcher {
    /**
     * Creates instance of ModelPrs_SelectionManager.
     */
    constructor(theScene: ModelPrs_Scene);
    /**
     * Number of highlighted items.
     */
    get numberHighlightedItems(): number;
    /**
     * Number of selected items.
     */
    get numberOfSelectedItems(): number;
    /**
     * Pick tolerance in pixels for line and point picking. Default is 5px.
     */
    pickTolerance: number;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_SelectionManagerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_SelectionManagerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Deselects a specific selection item. Returns `true` if the item has been successfully deselected.
     */
    deselect(theItem: ModelPrs_SelectionItem, theDispatchEvent?: boolean): boolean;
    /**
     * Deselects any selected items on the scene.
     */
    deselectAll(theDispatchEvent?: boolean): void;
    /**
     * Deselects node on the scene.
     */
    deselectNode(theNode: ModelPrs_SceneNode, theDispatchEvent?: boolean): boolean;
    /**
     * Highlights a specific item. Returns `false` if the item is cannot be highlighted or already highlighted.
     */
    highlight(theItem: ModelPrs_HighlightingItem, theDispatchEvent?: boolean): boolean;
    /**
     * Returns a highlighted item.
     */
    highlightedItem(): ModelPrs_HighlightingItem | null;
    /**
     * Highlight the object on the scene at the pixel coordinates of the viewport.
     * (0, 0) coords corresponds to the top-left corner of the viewport.
     */
    highlightFromViewport(theX: number, theY: number, theViewport: ModelPrs_ViewPort): void;
    /**
     * Highlights specific node on the scene including all child nodes.
     * Returns `true` if the node has been highlighted.
     */
    highlightNode(theNode: ModelPrs_SceneNode, theDispatchEvent?: boolean): boolean;
    /**
     * Invert selection of specific node on the scene.
     * If the node is selected it will be deselected. If the node is not selected it will be selected.
     * Returns `false` if the node is cannot be selected/deselected.
     */
    invertNodeSelection(theNode: ModelPrs_SceneNode, theDispatchEvent?: boolean): boolean;
    /**
     * Inverts selection of specific item.
     * If the item is selected it will be deselected. If the item is not selected it will be selected.
     * Returns `false` if the item is cannot be selected/deselected.
     */
    invertSelection(theItem: ModelPrs_SelectionItem, theDispatchEvent?: boolean): boolean;
    /**
     * Picks the objects on the scene from the word-space point and direction.
     */
    pick(theOrigin: ModelData_XYZ, theDirection: ModelData_XYZ): ModelPrs_PickResult | null;
    /**
     * Picks the objects on the scene at the pixel coordinates of the viewport.
     * (0, 0) coords corresponds to the top-left corner of the viewport.
     */
    pickFromViewport(theX: number, theY: number, theViewport: ModelPrs_ViewPort): ModelPrs_PickResult | null;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_SelectionManager#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_SelectionManagerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_SelectionManagerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Selects a specific selection item. Returns `false` if the item is cannot be selected or already selected.
     */
    select(theItem: ModelPrs_SelectionItem, theBreakSelection?: boolean, theDispatchEvent?: boolean): boolean;
    /**
     * Returns iterable to selected items.
     * 
     * <span class="doxygen-js"></span>
     * ```js
     * for (const item of selectionManager.selectedItems()) {
     *   // Access to the selected item
     * }
     * ```
     */
    selectedItems(): Iterable<ModelPrs_SelectionItem>;
    /**
     * Select the objects on the scene at the pixel coordinates of the viewport.
     * (0, 0) coords corresponds to the top-left corner of the viewport.
     */
    selectFromViewport(theX: number, theY: number, theViewport: ModelPrs_ViewPort, theBreakSelection?: boolean): void;
    /**
     * Selects specific node on the scene including all child nodes.
     * Returns `true` if the node has been selected.
     */
    selectNode(theNode: ModelPrs_SceneNode, theBreakSelection?: boolean, theDispatchEvent?: boolean): boolean;
    /**
     * Unhighlights any highlighted items on the scene.
     */
    unhighlightAll(theDispatchEvent?: boolean): void;
}

/**
 * Selection mode of the scene node.
 */
export enum ModelPrs_SelectionMode {
    None = 0,
    Node = 1,
    Body = 2,
    Solid = 4,
    Shell = 8,
    Face = 16,
    Wire = 32,
    Edge = 64,
    Vertex = 128,
    PolyShape = 256,
    PolyVertex = 2048,
    Undefined = 32768,
}


export type ModelPrs_SinglePointInputHandlerEventMap<SinglePointInputHandlerType extends ModelPrs_SinglePointInputHandler> = ModelPrs_PointerInputHandlerEventMap<SinglePointInputHandlerType> & {
    pointChanged: ModelPrs_Event<"pointChanged", SinglePointInputHandlerType>;
    isActiveChanged: ModelPrs_Event<"isActiveChanged", SinglePointInputHandlerType>;
}

/**
 * An intermediate class for the handlers which expect only a single point.
 */
export class ModelPrs_SinglePointInputHandler extends ModelPrs_PointerInputHandler {
    /**
     * Creates an instance of ModelPrs_SinglePointInputHandler.
     */
    constructor();
    /**
     * Indicates whenever handler detects drag gesture.
     */
    get isActive(): boolean;
    /**
     * Pressed point data. `null` if handler is inactive.
     */
    get point(): ModelPrs_InputHandlerPoint | null;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_SinglePointInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_SinglePointInputHandlerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_SinglePointInputHandler#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_SinglePointInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_SinglePointInputHandlerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}


export type ModelPrs_StyleEventMap<StyleType extends ModelPrs_Style> = ModelPrs_FieldChangedEventMap<StyleType> & {
    changed: ModelPrs_Event<"changed", StyleType>;
}

/**
 * Defines style of the scene node.
 */
export class ModelPrs_Style extends ModelPrs_EventDispatcher {
    /**
     * Creates an instance of ModelPrs_Style.
     */
    constructor();
    /**
     * Appearance applied to scene node boundaries in {@link ModelPrs_DisplayMode ShadedWithBoundaries} display mode.
     */
    get boundariesDefaultAppearance(): ModelData_Appearance | null;
    set boundariesDefaultAppearance(theDefaultAppearance: ModelData_Appearance | null);
    /**
     * Appearance applied to the scene node boundaries in {@link ModelPrs_DisplayMode ShadedWithBoundaries} display mode when the node is in ghost mode.
     */
    get boundariesGhostModeAppearance(): ModelData_Appearance | null;
    set boundariesGhostModeAppearance(theGhostModeAppearance: ModelData_Appearance | null);
    /**
     * Appearance applied to the scene node boundaries in {@link ModelPrs_DisplayMode ShadedWithBoundaries} display mode when the node is highlighted.
     */
    get boundariesHighlightAppearance(): ModelData_Appearance | null;
    set boundariesHighlightAppearance(theHighlightAppearance: ModelData_Appearance | null);
    /**
     * Appearance applied to the scene node boundaries in {@link ModelPrs_DisplayMode ShadedWithBoundaries} display mode when the node is selected.
     */
    get boundariesSelectionAppearance(): ModelData_Appearance | null;
    set boundariesSelectionAppearance(theSelectionAppearance: ModelData_Appearance | null);
    /**
     * Default appearance applied to scene node before applying any appearance.
     */
    get defaultAppearance(): ModelData_Appearance | null;
    set defaultAppearance(theDefaultAppearance: ModelData_Appearance | null);
    /**
     * Appearance applied when scene node is in ghost mode.
     */
    get ghostModeAppearance(): ModelData_Appearance | null;
    set ghostModeAppearance(theGhostModeAppearance: ModelData_Appearance | null);
    /**
     * Appearance applied when scene node is highlighted.
     */
    get highlightAppearance(): ModelData_Appearance | null;
    set highlightAppearance(theHighlightAppearance: ModelData_Appearance | null);
    /**
     * Appearance applied when scene node is selected.
     */
    get selectionAppearance(): ModelData_Appearance | null;
    set selectionAppearance(theSelectionAppearance: ModelData_Appearance | null);
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_StyleEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_StyleEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Creates copy of the current style.
     */
    clone(): ModelPrs_Style;
    /**
     * Combine style with current.
     */
    combineWith(theStyle: ModelPrs_Style): this;
    /**
     * Copies style attributes from another style.
     */
    copy(theStyle: ModelPrs_Style): this;
    /**
     * Copies internal contents and combines with attributes from another style.
     */
    copyAndCombineWith(theStyle: ModelPrs_Style): ModelPrs_Style;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_Style#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_StyleEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_StyleEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
}


export type ModelPrs_TapInputHandlerEventMap<TapInputHandlerType extends ModelPrs_SinglePointInputHandler> = ModelPrs_SinglePointInputHandlerEventMap<TapInputHandlerType> & {
    tap: ModelPrs_Event<"tap", TapInputHandlerType>;
    doubleTap: ModelPrs_Event<"doubleTap", TapInputHandlerType>;
    longPress: ModelPrs_Event<"longPress", TapInputHandlerType>;
}

/**
 * A handler for taps on a touchscreen or clicks on a mouse.
 */
export class ModelPrs_TapInputHandler extends ModelPrs_SinglePointInputHandler {
    /**
     * Creates an instance of ModelPrs_TapInputHandler.
     */
    constructor();
    /**
     * The the maximum distance, in pixels, that a pointer can be moved between two consecutive taps
     * and still have it detected as a double-tap. Default is 5 pixels.
     */
    get doubleTapDistance(): number;
    set doubleTapDistance(theDoubleTapDistance: number);
    /**
     * The time limit in milliseconds that distinguishes a double taps from two consecutive pointer taps.
     * Default is 400ms.
     */
    doubleTapInterval: number;
    /**
     * The time in milliseconds that a point must be pressed in order to trigger a long press gesture.
     * Default is 500ms.
     */
    longPressInterval: number;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_TapInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_TapInputHandlerEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Handles double tap event fires when a pointing device button (such as a mouse's primary button) is double-clicked;
     * that is, when it's rapidly clicked twice on a single element within a very short span of time.
     * 
     * By default it just dispatches `doubleTap` {@link ModelPrs_PointerInputEvent event}.
     */
    doubleTap(theEvent: ModelPrs_PointerInputEvent): void;
    /**
     * Handles long press event fires when a pointing device button (such as a mouse's primary button) is pressed and held for a time
     * greater than `longPressInterval`.
     * 
     * By default it just dispatches `longPress` {@link ModelPrs_PointerInputEvent event}.
     */
    longPress(theEvent: ModelPrs_PointerInputEvent): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_TapInputHandler#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_TapInputHandlerEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_TapInputHandlerEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Handles tap event fired when a pointing device button (such as a mouse's primary mouse button)
     * is both pressed and released within a time period less than while the pointer is located inside the element.
     * 
     * By default it just dispatches `tap` {@link ModelPrs_PointerInputEvent event}.
     */
    tap(theEvent: ModelPrs_PointerInputEvent): void;
}

/**
 * {@link ModelPrs_ViewPort} configuration interface.
 */
export type ModelPrs_ViewPortConfig = {
    [index: string]: any;
    /**
     * Shows view cube control at the top right corner. Default is <code>true</code>.
     */
    showViewCube?: boolean;
    /**
     * Resize canvas on window <code>'resize'</code> event. Default is <code>true</code>.
     */
    autoResize?: boolean;
    /**
     * Tab index which will be assigned to canvas. Default is <code>0</code>.
     */
    tabIndex?: number;
    /**
     * Adds default lights or not. Default is <code>true</code>.
     */
    addDefaultLights?: boolean;
    /**
     * Adds default camera input handler. Default is <code>true</code>.
     */
    addDefaultInputHandlers?: boolean;
}


export type ModelPrs_ViewPortEventMap<ViewPortType extends ModelPrs_ViewPort> = {
    resized: ModelPrs_ViewPortResizeEvent<ViewPortType>;
    frameRendered: ModelPrs_Event<"frameRendered", ViewPortType>;
}

/**
 * Defines a viewport paddings in pixels.
 */
export type ModelPrs_ViewportPaddings = {
    left?: number;
    right?: number;
    top?: number;
    bottom?: number;
}

/**
 * Event emitted when the {@link ModelPrs_ViewPort viewport} has been resized.
 */
export type ModelPrs_ViewPortResizeEvent<ViewPortType extends ModelPrs_ViewPort = ModelPrs_ViewPort> = ModelPrs_Event<"resized",ViewPortType> & {
    width: number;
    height: number;
}

/**
 * Add viewer to dom element.
 */
export class ModelPrs_ViewPort extends ModelPrs_EventDispatcher {
    constructor(theConfig?: ModelPrs_ViewPortConfig, theDomElement?: HTMLElement);
    /**
     * Viewport camera.
     */
    get camera(): ModelPrs_Camera;
    /**
     * Canvas element.
     */
    get canvas(): HTMLCanvasElement;
    /**
     * Viewport clipping planes manager.
     */
    get clipPlanesManager(): ModelPrs_ClipPlanesManager;
    set clipPlanesManager(theClipPlanesManager: ModelPrs_ClipPlanesManager);
    /**
     * Dom element.
     */
    get domElement(): HTMLElement;
    /**
     * Model explosion manager.
     */
    get exploder(): ModelPrs_Exploder;
    set exploder(theExploder: ModelPrs_Exploder);
    /**
     * Viewport hight.
     */
    get height(): number;
    /**
     * Viewport input manager.
     */
    get inputManager(): ModelPrs_InputManager;
    set inputManager(theInputManager: ModelPrs_InputManager);
    /**
     * Viewport lights manager.
     */
    get lightsManager(): ModelPrs_LightsManager;
    set lightsManager(theLightsManager: ModelPrs_LightsManager);
    /**
     * Viewport markers manager.
     */
    get markerManager(): ModelPrs_MarkersManager;
    set markerManager(theMarkerManager: ModelPrs_MarkersManager);
    /**
     * A scene to which the viewport is attached.
     */
    get scene(): ModelPrs_Scene | null;
    /**
     * Viewport width.
     */
    get width(): number;
    /**
     * Adds the specified JavaScript function to the list of event listeners for the specified event type on which it is called.
     */
    addEventListener<K extends keyof ModelPrs_ViewPortEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ViewPortEventMap<this>[K]>): void;
    addEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Attach current viewport to the scene to render its content.
     */
    attachToScene(theScene: ModelPrs_Scene): void;
    /**
     * Detach current viewport from the scene.
     */
    detachFromScene(): void;
    /**
     * Adjust the camera so that the entire scene is fully in its field of view.
     * `thePaddings` specifies the paddings in pixels or padding in % of viewport size for all sides at once.
     */
    fitAll(thePaddings?: ModelPrs_ViewportPaddings | number): void;
    /**
     * Adjust the camera so that the given bounding box is fully in its field of view.
     * `thePaddings` specifies the paddings in pixels or coefficient in % of viewport size for all sides at once.
     */
    fitBox(theBox: ModelData_Box, thePaddings?: ModelPrs_ViewportPaddings | number): void;
    /**
     * Adjust the camera so that the given scene node is fully in its field of view.
     * `thePaddings` specifies the paddings in pixels or padding in % of viewport size for all sides at once.
     */
    fitNode(theNode: ModelPrs_SceneNode, thePaddings?: ModelPrs_ViewportPaddings | number): void;
    /**
     * Removes an event listener previously registered with {@link ModelPrs_ViewPort#addEventListener addEventListener()}.
     */
    removeEventListener<K extends keyof ModelPrs_ViewPortEventMap<this>>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this, ModelPrs_ViewPortEventMap<this>[K]>): void;
    removeEventListener<K extends string>(theType: K, theListener: ModelPrs_EventDispatcherListenerType<K, this>): void;
    /**
     * Resizes viewport.
     */
    resize(theWidth: number, theHeight: number): void;
    /**
     * Schedules new frame rendering.
     */
    update(): void;
}

/**
 * Visibility mode of the {@link ModelPrs_SceneNode}
 */
export enum ModelPrs_VisibilityMode {
    Visible = 0,
    GhostlyHidden = 1,
    Hidden = 2,
    Undefined = 100,
}

/**
 * Creates an instance of ModelPrs_WheelInputEvent.
 */
export class ModelPrs_WheelInputEvent<TypeType extends string = string, TargetType extends ModelPrs_InputHandler = ModelPrs_InputHandler> extends ModelPrs_InputEvent<TypeType,TargetType> {
    /**
     * Returns a double representing the scroll amount.
     */
    get delta(): number;
    /**
     * Creates wheel input event from system event.
     */
    static fromWheelEvent(theEvent: WheelEvent, theViewport: ModelPrs_ViewPort): ModelPrs_WheelInputEvent;
}

/**
 * This module is a UMD module that exposes a global variable 'cadex' when
 * loaded outside a module loader environment
 */
export as namespace cadex;
